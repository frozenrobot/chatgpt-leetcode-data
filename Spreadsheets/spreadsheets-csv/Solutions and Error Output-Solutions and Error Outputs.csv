Index,Problem Level,Problem Number,Initial Attempt Code,Error output,2nd attempt code,Error output,3rd attempt code,Error output,4th attempt code,Error output,5th attempt code,Error output,6th attempt code,Error output,"Runtime, memory",1st improvement code,"Runtime, memory",2nd improvement code,"Runtime, memory",3rd improvement code,"Runtime, memory",4th improvement code,"Runtime, memory",5th improvement code,"Runtime, memory",Error output
1,Easy,1652,"class Solution(object):
    def decrypt(self, code, k):
        n = len(code)
        decrypted = [0] * n
        
        if k > 0:
            for i in range(n):
                for j in range(1, k+1):
                    decrypted[i] += code[(i+j)%n]
        elif k < 0:
            for i in range(n):
                for j in range(1, -k+1):
                    decrypted[i] += code[(i-j+n)%n]
        
        return decrypted
",,,,,,,,,,,,"31.91, 31.91","class Solution(object):
    def decrypt(self, code, k):
        n = len(code)
        decrypted = [0] * n
        
        if k != 0:
            window_sum = sum(code[1:k+1] if k > 0 else code[k:n] + code[:k])
            for i in range(n):
                decrypted[i] = window_sum
                window_sum -= code[(i+1)%n] if k > 0 else code[(i+k)%n]
                window_sum += code[(i+k+1)%n]
        
        return decrypted
",,,,,,,,,,"Wrong Answer

43 / 74 testcases passed
Input
code =
[2,4,9,3]
k =
-2
Use Testcase

Output
[18,12,11,13]
Expected
[12,5,6,13]
"
2,Easy,111,"class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution(object):
    def minDepth(self, root):
        if root is None:
            return 0

        # If the current node is a leaf node, return 1
        if root.left is None and root.right is None:
            return 1

        # If the left subtree is empty, recur for the right subtree
        if root.left is None:
            return self.minDepth(root.right) + 1

        # If the right subtree is empty, recur for the left subtree
        if root.right is None:
            return self.minDepth(root.left) + 1

        # If both subtrees are present, take the minimum depth
        left_depth = self.minDepth(root.left)
        right_depth = self.minDepth(root.right)
        return min(left_depth, right_depth) + 1
",,,,,,,,,,,,"42.73, 33.37","from collections import deque

class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution(object):
    def minDepth(self, root):
        if root is None:
            return 0

        # Create a queue for BFS
        queue = deque([(root, 1)])

        while queue:
            node, depth = queue.popleft()

            # Check if the current node is a leaf node
            if node.left is None and node.right is None:
                return depth

            # Add the left and right children to the queue
            if node.left is not None:
                queue.append((node.left, depth + 1))
            if node.right is not None:
                queue.append((node.right, depth + 1))
","89.53, 95.32","from collections import deque

class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution(object):
    def minDepth(self, root):
        if root is None:
            return 0

        queue = deque([(root, 1)])

        while queue:
            node, depth = queue.popleft()

            # Check if the current node is a leaf node
            if node.left is None and node.right is None:
                return depth

            # Add the left and right children to the queue
            if node.left is not None:
                queue.append((node.left, depth + 1))
            
            if node.right is not None:
                queue.append((node.right, depth + 1))
","77.9, 89.4","class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution(object):
    def minDepth(self, root):
        if root is None:
            return 0

        # Initialize the minimum depth as infinity
        min_depth = float('inf')

        def dfs(node, depth):
            nonlocal min_depth

            # If the current node is a leaf node, update the minimum depth
            if node.left is None and node.right is None:
                min_depth = min(min_depth, depth)
                return

            # Recur for the left and right subtrees if they exist
            if node.left is not None:
                dfs(node.left, depth + 1)
            if node.right is not None:
                dfs(node.right, depth + 1)

        # Start the depth-first search from the root node
        dfs(root, 1)

        return min_depth
",,,,,,"Runtime Error
0 / 52 testcases passed
SyntaxError: invalid syntax
                     ^
    nonlocal min_depth
Line 16  (Solution.py)
Last Executed Input
Use Testcase


root =
[3,9,20,null,null,15,7]

"
3,Easy,1491,"class Solution(object):
    def average(self, salary):
        # Exclude the minimum and maximum salary
        salary.sort()
        n = len(salary)
        total = sum(salary[1:n-1])
        # Calculate the average
        average = total / (n-2)
        return average
","Wrong Answer

20 / 43 testcases passed
Input
salary =
[48000,59000,99000,13000,78000,45000,31000,17000,39000,37000,93000,77000,33000,28000,4000,54000,67000,6000,1000,11000]
Use Testcase

Output
41111.00000
Expected
41111.11111


","class Solution(object):
    def average(self, salary):
        # Exclude the minimum and maximum salary
        min_salary = min(salary)
        max_salary = max(salary)
        total = sum(salary) - min_salary - max_salary
        # Calculate the average
        average = total / (len(salary) - 2)
        return average
","Wrong Answer

20 / 43 testcases passed
Input
salary =
[48000,59000,99000,13000,78000,45000,31000,17000,39000,37000,93000,77000,33000,28000,4000,54000,67000,6000,1000,11000]
Use Testcase

Output
41111.00000
Expected
41111.11111


","class Solution(object):
    def average(self, salary):
        # Exclude the minimum and maximum salary
        sorted_salary = sorted(salary)
        total = sum(sorted_salary[1:-1])
        # Calculate the average
        average = total / (len(salary) - 2)
        return average
","Wrong Answer

20 / 43 testcases passed
Input
salary =
[48000,59000,99000,13000,78000,45000,31000,17000,39000,37000,93000,77000,33000,28000,4000,54000,67000,6000,1000,11000]
Use Testcase

Output
41111.00000
Expected
41111.11111


","class Solution(object):
    def average(self, salary):
        min_salary = float('inf')
        max_salary = float('-inf')
        total = 0

        for s in salary:
            total += s
            min_salary = min(min_salary, s)
            max_salary = max(max_salary, s)

        average = (total - min_salary - max_salary) / (len(salary) - 2)
        return average
","Wrong Answer

20 / 43 testcases passed
Input
salary =
[48000,59000,99000,13000,78000,45000,31000,17000,39000,37000,93000,77000,33000,28000,4000,54000,67000,6000,1000,11000]
Use Testcase

Output
41111.00000
Expected
41111.11111


","class Solution(object):
    def average(self, salary):
        min_salary = min(salary)
        max_salary = max(salary)
        total = sum(salary) - min_salary - max_salary
        count = len(salary) - 2
        average = total / count
        return average
","Wrong Answer

20 / 43 testcases passed
Input
salary =
[48000,59000,99000,13000,78000,45000,31000,17000,39000,37000,93000,77000,33000,28000,4000,54000,67000,6000,1000,11000]
Use Testcase

Output
41111.00000
Expected
41111.11111


","class Solution(object):
    def average(self, salary):
        sorted_salary = sorted(salary)
        total = sum(sorted_salary[1:-1])
        count = len(sorted_salary) - 2
        average = total / count
        return average
","Wrong Answer

20 / 43 testcases passed
Input
salary =
[48000,59000,99000,13000,78000,45000,31000,17000,39000,37000,93000,77000,33000,28000,4000,54000,67000,6000,1000,11000]
Use Testcase

Output
41111.00000
Expected
41111.11111


",,,,,,,,,,,,
4,Easy,876,"# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next

class Solution(object):
    def middleNode(self, head):
        """"""
        :type head: ListNode
        :rtype: ListNode
        """"""
        slow = fast = head

        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next

        return slow
",,,,,,,,,,,,"75.44, 97.18","# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next

class Solution(object):
    def middleNode(self, head):
        """"""
        :type head: ListNode
        :rtype: ListNode
        """"""
        length = 0
        curr = head

        while curr:
            length += 1
            curr = curr.next

        middle = length // 2
        curr = head

        for _ in range(middle):
            curr = curr.next

        return curr
","32.66, 54.31","# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next

class Solution(object):
    def middleNode(self, head):
        """"""
        :type head: ListNode
        :rtype: ListNode
        """"""
        slow = fast = head

        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next

        return slow
","30.44, 80.48",X,,,,,,
5,Easy,1979,"class Solution(object):
    def findGCD(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        # Find the smallest and largest numbers in the array
        smallest = min(nums)
        largest = max(nums)
        
        # Compute the greatest common divisor using Euclidean algorithm
        def gcd(a, b):
            while b:
                a, b = b, a % b
            return a
        
        # Return the greatest common divisor of the smallest and largest numbers
        return gcd(smallest, largest)
",,,,,,,,,,,,"39.43, 78.29","import math

class Solution(object):
    def findGCD(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        # Find the smallest and largest numbers in the array
        smallest = min(nums)
        largest = max(nums)
        
        # Return the greatest common divisor of the smallest and largest numbers
        return math.gcd(smallest, largest)
",,,,,,,,,,"Runtime Error

AttributeError: 'module' object has no attribute 'gcd'
    return math.gcd(smallest, largest)
Line 14 in findGCD (Solution.py)
    ret = Solution().findGCD(param_1)
Line 34 in _driver (Solution.py)
    _driver()
Line 44 in <module> (Solution.py)

Last Executed Input

[2,5,6,9,10]


"
6,Easy,409,"class Solution(object):
    def longestPalindrome(self, s):
        char_count = {}
        for char in s:
            char_count[char] = char_count.get(char, 0) + 1

        longest_length = 0
        odd_count = 0
        for count in char_count.values():
            if count % 2 == 0:
                longest_length += count
            else:
                longest_length += count - 1
                odd_count = 1

        return longest_length + odd_count
",,,,,,,,,,,,"74.41, 65.68","class Solution(object):
    def longestPalindrome(self, s):
        char_count = [0] * 52
        for char in s:
            if 'a' <= char <= 'z':
                index = ord(char) - ord('a')
            else:
                index = ord(char) - ord('A') + 26
            char_count[index] += 1

        longest_length = 0
        odd_count = 0
        for count in char_count:
            if count % 2 == 0:
                longest_length += count
            else:
                longest_length += count - 1
                odd_count = 1

        return longest_length + odd_count
","89.5, 90.9","class Solution(object):
    def longestPalindrome(self, s):
        char_count = [0] * 52
        odd_count = 0

        for char in s:
            if 'a' <= char <= 'z':
                index = ord(char) - ord('a')
            else:
                index = ord(char) - ord('A') + 26
            char_count[index] += 1

            if char_count[index] % 2 == 0:
                odd_count -= 1
            else:
                odd_count += 1

        longest_length = len(s) - odd_count
        if odd_count > 0:
            longest_length += 1

        return longest_length
","74.41, 65.68","from collections import Counter

class Solution(object):
    def longestPalindrome(self, s):
        char_count = Counter(s)
        odd_count = set()

        for count in char_count.values():
            if count % 2 != 0:
                odd_count.add(count)

        longest_length = len(s) - len(odd_count)
        if len(odd_count) > 0:
            longest_length += 1

        return longest_length
",,,,,,"Wrong Answer

37 / 95 testcases passed
Input
s =
""abccccdd""
Use Testcase

Output
8
Expected
7


"
7,Easy,976,"class Solution(object):
    def largestPerimeter(self, nums):
        nums.sort(reverse=True)  # Sort the side lengths in descending order
        
        for i in range(len(nums) - 2):
            a, b, c = nums[i], nums[i+1], nums[i+2]
            if a < b + c:  # Check if the side lengths can form a triangle
                return a + b + c
        
        return 0  # Return 0 if no triangle with non-zero area can be formed
",,,,,,,,,,,,"42.23, 70.53","class Solution(object):
    def largestPerimeter(self, nums):
        nums.sort(reverse=True)  # Sort the side lengths in descending order
        
        for i in range(len(nums) - 2):
            a, b, c = nums[i:i+3]  # Use slicing to avoid creating separate variables
            if a < b + c:  # Check if the side lengths can form a triangle
                return a + b + c
        
        return 0  # Return 0 if no triangle with non-zero area can be formed
","42.23, 90.2","class Solution(object):
    def largestPerimeter(self, nums):
        max_perimeter = 0
        n = len(nums)
        
        for i in range(n - 2):
            a = nums[i]
            b = nums[i + 1]
            c = nums[i + 2]
            
            if a < b + c:
                perimeter = a + b + c
                max_perimeter = max(max_perimeter, perimeter)
        
        return max_perimeter
",,,,,,,,"Wrong Answer

1 / 84 testcases passed
Input
nums =
[1,2,1,10]
Use Testcase

Output
13
Expected
0


"
8,Easy,933,"class RecentCounter(object):

    def __init__(self):
        self.requests = []

    def ping(self, t):
        self.requests.append(t)  # Add the new request to the list

        # Remove the requests that fall outside the time range [-2999, t]
        while self.requests and self.requests[0] < t - 3000:
            self.requests.pop(0)

        return len(self.requests)
",,,,,,,,,,,,"49.9, 87.27","from collections import deque

class RecentCounter(object):

    def __init__(self):
        self.requests = deque()

    def ping(self, t):
        self.requests.append(t)  # Add the new request to the deque

        # Remove the requests that fall outside the time range [-2999, t]
        while self.requests[0] < t - 3000:
            self.requests.popleft()

        return len(self.requests)

","66.67, 20","class RecentCounter(object):

    def __init__(self):
        self.requests = [0] * 10000  # Initialize a circular buffer of size 10000
        self.start = 0
        self.end = 0
        self.size = 0

    def ping(self, t):
        self.requests[self.end] = t  # Add the new request to the circular buffer
        self.end = (self.end + 1) % 10000  # Increment the end pointer
        self.size += 1

        # Remove the requests that fall outside the time range [-2999, t]
        while self.requests[self.start] < t - 3000:
            self.start = (self.start + 1) % 10000  # Increment the start pointer
            self.size -= 1

        return self.size
","38.79, 7.27","from collections import deque

class RecentCounter(object):

    def __init__(self):
        self.requests = deque()

    def ping(self, t):
        self.requests.append(t)  # Add the new request to the deque

        # Remove the requests that fall outside the time range [-2999, t]
        while self.requests[0] < t - 3000:
            self.requests.popleft()

        return len(self.requests)

","83.64, 7.27","class RecentCounter(object):

    def __init__(self):
        self.requests = []
        self.start = 0

    def ping(self, t):
        self.requests.append(t)  # Add the new request to the list

        # Move the start pointer until it points to the first valid request
        while self.requests[self.start] < t - 3000:
            self.start += 1

        return len(self.requests) - self.start

","60, 36.97","class RecentCounter(object):

    def __init__(self):
        self.requests = []
        self.window_start = 0

    def ping(self, t):
        self.requests.append(t)  # Add the new request to the list

        # Remove the requests that fall outside the time range [-2999, t]
        while self.requests[self.window_start] < t - 3000:
            self.window_start += 1

        return len(self.requests) - self.window_start

","20, 20",
9,Easy,389,"class Solution(object):
    def findTheDifference(self, s, t):
        """"""
        :type s: str
        :type t: str
        :rtype: str
        """"""
        s_dict = {}
        t_dict = {}
        
        # Count the frequency of each character in string s
        for char in s:
            s_dict[char] = s_dict.get(char, 0) + 1
        
        # Count the frequency of each character in string t
        for char in t:
            t_dict[char] = t_dict.get(char, 0) + 1
        
        # Compare the frequencies of characters in s and t
        for char in t_dict:
            if char not in s_dict or t_dict[char] > s_dict[char]:
                return char
",,,,,,,,,,,,"88.23, 71.1","class Solution(object):
    def findTheDifference(self, s, t):
        """"""
        :type s: str
        :type t: str
        :rtype: str
        """"""
        xor_value = 0
        
        # XOR all the characters in string s and t
        for char in s + t:
            xor_value ^= ord(char)
        
        # The remaining XOR value will be the ASCII value of the added letter
        return chr(xor_value)
","88.23, 71.1","class Solution(object):
    def findTheDifference(self, s, t):
        """"""
        :type s: str
        :type t: str
        :rtype: str
        """"""
        difference = 0
        
        # Calculate the ASCII value difference between characters in s and t
        for char in s + t:
            difference += ord(char)
        
        # The remaining difference will be the ASCII value of the added letter
        return chr(difference)
",,,,,,,,"Runtime Error
0 / 54 testcases passed
ValueError: chr() arg not in range(256)
    return chr(difference)
Line 15 in findTheDifference (Solution.py)
    ret = Solution().findTheDifference(param_1, param_2)
Line 40 in _driver (Solution.py)
    _driver()
Line 50 in <module> (Solution.py)
Last Executed Input
Use Testcase

s =
""abcd""

t =
""abcde""

"
10,Easy,387,"class Solution(object):
    def firstUniqChar(self, s):
        """"""
        :type s: str
        :rtype: int
        """"""
        # Create a dictionary to store the count of each character in the string
        char_count = {}
        
        # Iterate through the string to count the occurrences of each character
        for char in s:
            char_count[char] = char_count.get(char, 0) + 1
        
        # Iterate through the string again to find the first non-repeating character
        for i in range(len(s)):
            if char_count[s[i]] == 1:
                return i
        
        # If no non-repeating character is found, return -1
        return -1
",,,,,,,,,,,,"56.41, 32.40","from collections import OrderedDict

class Solution(object):
    def firstUniqChar(self, s):
        """"""
        :type s: str
        :rtype: int
        """"""
        char_count = OrderedDict()  # Ordered dictionary to maintain the order of insertion
        
        # Iterate through the string
        for char in s:
            char_count[char] = char_count.get(char, 0) + 1
        
        # Iterate through the ordered dictionary to find the first non-repeating character
        for char, count in char_count.items():
            if count == 1:
                return s.index(char)
        
        # If no non-repeating character is found, return -1
        return -1
","27.32, 86.53","class Solution(object):
    def firstUniqChar(self, s):
        """"""
        :type s: str
        :rtype: int
        """"""
        char_count = [0] * 26  # List to store the count of each character (assuming lowercase English letters)
        
        # Iterate through the string to count the occurrences of each character
        for char in s:
            char_count[ord(char) - ord('a')] += 1
        
        # Iterate through the string again to find the first non-repeating character
        for i in range(len(s)):
            if char_count[ord(s[i]) - ord('a')] == 1:
                return i
        
        # If no non-repeating character is found, return -1
        return -1
","55.76, 18.2",X,,,,,,
11,Easy,144,"# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right

class Solution(object):
    def preorderTraversal(self, root):
        """"""
        :type root: TreeNode
        :rtype: List[int]
        """"""
        result = []
        self.preorderTraversalRecursive(root, result)
        return result
    
    def preorderTraversalRecursive(self, node, result):
        if node is None:
            return
        
        result.append(node.val)  # Visit the current node
        self.preorderTraversalRecursive(node.left, result)  # Traverse left subtree
        self.preorderTraversalRecursive(node.right, result)  # Traverse right subtree
",,,,,,,,,,,,"78.91, 75","# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right

class Solution(object):
    def preorderTraversal(self, root):
        """"""
        :type root: TreeNode
        :rtype: List[int]
        """"""
        if not root:
            return []
        
        result = []
        stack = [root]  # Use a stack to keep track of nodes
        
        while stack:
            node = stack.pop()  # Pop the top node from the stack
            result.append(node.val)  # Visit the current node
            
            # Push the right child first and then the left child to the stack
            if node.right:
                stack.append(node.right)
            if node.left:
                stack.append(node.left)
        
        return result
","95.36, 75","# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right

class Solution(object):
    def preorderTraversal(self, root):
        """"""
        :type root: TreeNode
        :rtype: List[int]
        """"""
        result = []
        curr = root
        
        while curr:
            if not curr.left:
                result.append(curr.val)
                curr = curr.right
            else:
                predecessor = curr.left
                
                while predecessor.right and predecessor.right != curr:
                    predecessor = predecessor.right
                
                if not predecessor.right:
                    result.append(curr.val)
                    predecessor.right = curr
                    curr = curr.left
                else:
                    predecessor.right = None
                    curr = curr.right
        
        return result
","78.91, 75","# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right

class Solution(object):
    def preorderTraversal(self, root):
        """"""
        :type root: TreeNode
        :rtype: List[int]
        """"""
        if not root:
            return []
        
        result = []
        stack = [root]
        
        while stack:
            node = stack.pop()
            result.append(node.val)
            
            if node.right:
                stack.append(node.right)
            if node.left:
                stack.append(node.left)
        
        return result
","65.82, 95.27","from collections import deque

# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right

class Solution(object):
    def preorderTraversal(self, root):
        """"""
        :type root: TreeNode
        :rtype: List[int]
        """"""
        if not root:
            return []
        
        result = []
        stack = deque([root])
        
        while stack:
            node = stack.pop()
            result.append(node.val)
            
            if node.right:
                stack.append(node.right)
            if node.left:
                stack.append(node.left)
        
        return result
","27.27, 49.9","# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right

class Solution(object):
    def preorderTraversal(self, root):
        """"""
        :type root: TreeNode
        :rtype: List[int]
        """"""
        if not root:
            return []
        
        result = []
        curr = root
        
        while curr:
            if not curr.left:
                result.append(curr.val)
                curr = curr.right
            else:
                predecessor = curr.left
                
                while predecessor.right and predecessor.right != curr:
                    predecessor = predecessor.right
                
                if not predecessor.right:
                    result.append(curr.val)
                    predecessor.right = curr
                    curr = curr.left
                else:
                    predecessor.right = None
                    curr = curr.right
        
        return result
","34.7, 45.59",
12,Easy,704,"class Solution(object):
    def search(self, nums, target):
        """"""
        :type nums: List[int]
        :type target: int
        :rtype: int
        """"""
        left, right = 0, len(nums) - 1

        while left <= right:
            mid = left + (right - left) // 2

            if nums[mid] == target:
                return mid
            elif nums[mid] < target:
                left = mid + 1
            else:
                right = mid - 1

        return -1
",,,,,,,,,,,,"46.23, 26.8","import bisect

class Solution(object):
    def search(self, nums, target):
        """"""
        :type nums: List[int]
        :type target: int
        :rtype: int
        """"""
        index = bisect.bisect_left(nums, target)
        if index < len(nums) and nums[index] == target:
            return index
        else:
            return -1
","20.8, 52.53","class Solution(object):
    def search(self, nums, target):
        """"""
        :type nums: List[int]
        :type target: int
        :rtype: int
        """"""
        return self.binary_search(nums, target, 0, len(nums) - 1)

    def binary_search(self, nums, target, left, right):
        if left > right:
            return -1

        mid = left + (right - left) // 2

        if nums[mid] == target:
            return mid
        elif nums[mid] < target:
            return self.binary_search(nums, target, mid + 1, right)
        else:
            return self.binary_search(nums, target, left, mid - 1)
","17.24, 96.69","class Solution(object):
    def search(self, nums, target):
        """"""
        :type nums: List[int]
        :type target: int
        :rtype: int
        """"""
        left, right = 0, len(nums) - 1

        while left <= right:
            mid = left + (right - left) // 2

            if nums[mid] == target:
                return mid
            elif nums[mid] < target:
                left = mid + 1
            else:
                right = mid - 1

        return -1
","24.42, 52.53",X,,,,
13,Easy,1176,"class Solution(object):
    def dietPlanPerformance(self, calories, k, lower, upper):
        points = 0
        total_calories = sum(calories[:k])
        
        if total_calories < lower:
            points -= 1
        elif total_calories > upper:
            points += 1
        
        for i in range(k, len(calories)):
            total_calories += calories[i] - calories[i-k]
            
            if total_calories < lower:
                points -= 1
            elif total_calories > upper:
                points += 1
        
        return points
",,,,,,,,,,,,"73.68, 52.63","class Solution(object):
    def dietPlanPerformance(self, calories, k, lower, upper):
        points = 0
        total_calories = sum(calories[:k])
        
        if total_calories < lower:
            points -= 1
        elif total_calories > upper:
            points += 1
        
        for i in range(k, len(calories)):
            total_calories += calories[i] - calories[i - k]
            
            if total_calories < lower:
                points -= 1
            elif total_calories > upper:
                points += 1
        
        return points
","31.58, 84.21","class Solution(object):
    def dietPlanPerformance(self, calories, k, lower, upper):
        points = 0
        total_calories = sum(calories[:k])
        
        if total_calories < lower:
            points -= 1
        elif total_calories > upper:
            points += 1
        
        for i in range(k, len(calories)):
            total_calories += calories[i] - calories[i - k]
            
            if total_calories < lower:
                points -= 1
            elif total_calories > upper:
                points += 1
        
        return points
","57.89, 84.21","class Solution(object):
    def dietPlanPerformance(self, calories, k, lower, upper):
        points = 0
        total_calories = 0
        
        for i, calorie in enumerate(calories):
            total_calories += calorie
            
            if i >= k - 1:
                if total_calories < lower:
                    points -= 1
                elif total_calories > upper:
                    points += 1
                
                total_calories -= calories[i - k + 1]
        
        return points
","21.5, 52.63","class Solution(object):
    def dietPlanPerformance(self, calories, k, lower, upper):
        points = 0
        total_calories = sum(calories[:k])
        
        if total_calories < lower:
            points -= 1
        elif total_calories > upper:
            points += 1
        
        for i in range(k, len(calories)):
            total_calories += calories[i] - calories[i - k]
            
            if total_calories < lower:
                points -= 1
            elif total_calories > upper:
                points += 1
        
        return points
","15.79, 31.58","class Solution(object):
    def dietPlanPerformance(self, calories, k, lower, upper):
        points = 0
        total_calories = sum(calories[:k])
        
        if total_calories < lower:
            points -= 1
        elif total_calories > upper:
            points += 1
        
        for i in range(k, len(calories)):
            total_calories += calories[i] - calories[i - k]
            
            if total_calories < lower:
                points -= 1
            elif total_calories > upper:
                points += 1
        
        return points
","47.37, 52.63",
14,Easy,1876,"class Solution(object):
    def countGoodSubstrings(self, s):
        count = 0
        for i in range(len(s) - 2):
            substring = s[i:i+3]
            if len(set(substring)) == 3:  # Check if all characters are unique
                count += 1
        return count
",,,,,,,,,,,,"88.94, 83.42","class Solution(object):
    def countGoodSubstrings(self, s):
        count = 0
        window = set()
        for i in range(len(s) - 2):
            if i > 0:
                window.remove(s[i - 1])
            window.add(s[i + 2])
            if len(window) == 3:
                count += 1
        return count
",,,,,,,,,,"Runtime Error
0 / 160 testcases passed
KeyError: u'x'
    window.remove(s[i - 1])
Line 7 in countGoodSubstrings (Solution.py)
    ret = Solution().countGoodSubstrings(param_1)
Line 31 in _driver (Solution.py)
    _driver()
Line 41 in <module> (Solution.py)
Last Executed Input
Use Testcase


s =
""xyzzaz""
"
15,Easy,157,"class Solution(object):
    def read(self, buf, n):
        """"""
        :type buf: Destination buffer (List[str])
        :type n: Number of characters to read (int)
        :rtype: The number of actual characters read (int)
        """"""
        # Create a buffer with enough space to store characters
        buf4 = [''] * 4
        total_chars = 0  # Counter for total characters read
        
        while total_chars < n:
            # Read up to 4 characters from the file
            chars_read = read4(buf4)
            
            # If no more characters to read, break the loop
            if chars_read == 0:
                break
            
            # Copy the characters from buf4 to buf
            for i in range(min(chars_read, n - total_chars)):
                buf[total_chars] = buf4[i]
                total_chars += 1
        
        return total_chars
",,,,,,,,,,,,"23.8, 88.46","class Solution(object):
    def read(self, buf, n):
        """"""
        :type buf: Destination buffer (List[str])
        :type n: Number of characters to read (int)
        :rtype: The number of actual characters read (int)
        """"""
        # Create a buffer with enough space to store characters
        buf4 = [''] * 4
        total_chars = 0  # Counter for total characters read
        eof = False  # Flag to indicate end of file
        
        while total_chars < n and not eof:
            # Read up to 4 characters from the file
            chars_read = read4(buf4)
            
            # If no more characters to read, set the end of file flag
            if chars_read < 4:
                eof = True
            
            # Copy the characters from buf4 to buf
            for i in range(min(chars_read, n - total_chars)):
                buf[total_chars] = buf4[i]
                total_chars += 1
        
        return total_chars
","80.77, 30.77","class Solution(object):
    def read(self, buf, n):
        """"""
        :type buf: Destination buffer (List[str])
        :type n: Number of characters to read (int)
        :rtype: The number of actual characters read (int)
        """"""
        # Create a buffer with enough space to store characters
        buf4 = [''] * 4
        total_chars = 0  # Counter for total characters read
        eof = False  # Flag to indicate end of file
        buf4_idx = 0  # Index for the buffer of characters read from read4
        buf4_chars = 0  # Number of characters read from read4
        
        while total_chars < n and (not eof or buf4_idx < buf4_chars):
            if buf4_idx == buf4_chars:
                # Only read from read4 when all characters in the buffer have been processed
                buf4_chars = read4(buf4)
                buf4_idx = 0
                if buf4_chars == 0:
                    # If no more characters to read, set the end of file flag
                    eof = True
            
            # Copy the characters from buf4 to buf
            while total_chars < n and buf4_idx < buf4_chars:
                buf[total_chars] = buf4[buf4_idx]
                total_chars += 1
                buf4_idx += 1
        
        return total_chars
","92.31, 30.77",X,,,,,,
16,Easy,2085,"class Solution(object):
    def countWords(self, words1, words2):
        count = 0
        word_count = {}

        # Count the occurrences of words in words1
        for word in words1:
            if word in word_count:
                word_count[word] += 1
            else:
                word_count[word] = 1

        # Count the occurrences of words in words2 and check if it appears exactly once in both arrays
        for word in words2:
            if word in word_count:
                word_count[word] += 1
                if word_count[word] == 2:  # If the word appears exactly once in both arrays
                    count += 1

        return count
","Wrong Answer

47 / 60 testcases passed
Input
words1 =
[""a"",""ab""]
words2 =
[""a"",""a"",""a"",""ab""]
Use Testcase

Output
2
Expected
1
","class Solution(object):
    def countWords(self, words1, words2):
        count = 0
        word_count = {}

        # Count the occurrences of words in words1
        for word in words1:
            if word in word_count:
                word_count[word] += 1
            else:
                word_count[word] = 1

        # Count the occurrences of words in words2 and check if it appears exactly once in both arrays
        for word in words2:
            if word in word_count:
                word_count[word] -= 1
                if word_count[word] == 0:  # If the word appears exactly once in both arrays
                    count += 1

        return count
","Wrong Answer

47 / 60 testcases passed
Input
words1 =
[""a"",""ab""]
words2 =
[""a"",""a"",""a"",""ab""]
Use Testcase

Output
2
Expected
1
","from collections import Counter

class Solution(object):
    def countWords(self, words1, words2):
        count = 0
        counter1 = Counter(words1)
        counter2 = Counter(words2)

        for word, freq in counter1.items():
            if freq == 1 and counter2[word] == 1:
                count += 1

        return count
",,,,,,,,"90.37, 79.26","from collections import Counter

class Solution(object):
    def countWords(self, words1, words2):
        count = 0
        word_count = Counter(words1 + words2)

        for freq in word_count.values():
            if freq == 2:  # If the word appears exactly once in both arrays
                count += 1

        return count
",,,,,,,,,,"Wrong Answer

38 / 60 testcases passed
Input
words1 =
[""bjxzvssdoq"",""oom"",""lxrrvf"",""aoeselhvrnw"",""awnornqyztqlza"",""bjxqkapuvaw"",""wibxruerngdzgjd"",""rezrwdzvllpbjpnikhzraz"",""pswmnrsepudx"",""nlicjldpeia"",""glg"",""nllxfcjjitmsuugmr"",""cl"",""pysmpgjakkjnusfopphb"",""zxlwcdjpn"",""xktsfnchwrdesnf"",""qptnoxxgrjmvr"",""exlfwjfsbsirbbkyqjtinrrwuhh"",""rqbnghajxygilgdjejopyuwyjqrx"",""vrjkqsicuqoalqyaxkaaogxbf"",""ixnlltqbpygmpjuspom"",""izajsxotcbhzdnkujwgdzo"",""b"",""lighabre"",""i"",""ljqqbfddipvcooh"",""hboedpepeeunx"",""bkhzhiefammwqkhvampokd"",""ptlozguwmyyp"",""loeshsjgazzwvs"",""kyrltbdzlymjxtvwiiq"",""fk"",""mbjpgwsahkgkehlcoqbhunqchxj"",""nfyuvlrmiturheb"",""cyqwsiysmoirurj"",""sciqruywy"",""pods...
View all 

words2 =
[""eeormvovhzslwsqgzthlgntgzc"",""zfwownznh"",""suxrkdbjdjjtbkjucsbyk"",""u"",""y"",""lbjooktoctgwbbptiffytquha"",""dcsxrghgpultkatbecjadbespvww"",""vwduylshcpaiu"",""rtcxwctvquaiuwkgvdx"",""a"",""szearxmdqcismljmihbtkcirztdnrc"",""htgmuxtxdunsvfizb"",""hybe"",""nsegkgwcvopncmfpaahhhjeuqjosv"",""jtarnnpppxtzmopixeijqqahkd"",""hazcgrrnpourkyoeanodejiptne"",""kurhokvhixihe"",""ljwycewmecfqdhtxiokjn"",""qgjzzvpyvwetlsvcsw"",""aunns"",""nwcnfrzzvxafkfjfnczummtubikji"",""nipiygnvlfntgpxfedj"",""mgnt"",""xvjehufvaqouhztnmts"",""sjtbrfjwtqxakqktxjaljrbwfoxvz"",""dfeujeikfrtrpiafrgxvjlkpxtog"",""u"",""ggbcxoasodaqaazulrxjleecexey"",""inedrgssajhpygfvozigohis""...
View all 

Use Testcase

Output
1
Expected
0


"
17,Easy,67,"class Solution(object):
    def addBinary(self, a, b):
        """"""
        :type a: str
        :type b: str
        :rtype: str
        """"""
        carry = 0
        result = []
        i, j = len(a) - 1, len(b) - 1
        
        while i >= 0 or j >= 0 or carry:
            num1 = int(a[i]) if i >= 0 else 0
            num2 = int(b[j]) if j >= 0 else 0
            current_sum = num1 + num2 + carry
            result.append(str(current_sum % 2))
            carry = current_sum // 2
            i -= 1
            j -= 1
        
        result.reverse()
        return ''.join(result)
",,,,,,,,,,,,"11.54, 75.7","class Solution(object):
    def addBinary(self, a, b):
        """"""
        :type a: str
        :type b: str
        :rtype: str
        """"""
        carry = 0
        result = []
        i, j = len(a) - 1, len(b) - 1
        
        while i >= 0 or j >= 0 or carry:
            num1 = int(a[i]) if i >= 0 else 0
            num2 = int(b[j]) if j >= 0 else 0
            current_sum = num1 + num2 + carry
            result.append(str(current_sum % 2))
            carry = current_sum // 2
            i -= 1
            j -= 1
        
        return ''.join(result[::-1])
","67.5, 48.6","class Solution(object):
    def addBinary(self, a, b):
        """"""
        :type a: str
        :type b: str
        :rtype: str
        """"""
        carry = 0
        result = []
        i, j = len(a) - 1, len(b) - 1
        
        while i >= 0 or j >= 0 or carry:
            num1 = int(a[i]) if i >= 0 else 0
            num2 = int(b[j]) if j >= 0 else 0
            current_sum = num1 + num2 + carry
            result.append(str(current_sum % 2))
            carry = current_sum // 2
            i -= 1
            j -= 1
        
        return ''.join(result[::-1])
","34.96, 48.6","class Solution(object):
    def addBinary(self, a, b):
        """"""
        :type a: str
        :type b: str
        :rtype: str
        """"""
        carry = 0
        result = []
        i, j = len(a) - 1, len(b) - 1
        
        while i >= 0 or j >= 0 or carry:
            digit_sum = carry
            if i >= 0:
                digit_sum += int(a[i])
                i -= 1
            if j >= 0:
                digit_sum += int(b[j])
                j -= 1
            result.append(str(digit_sum % 2))
            carry = digit_sum // 2
        
        return ''.join(result[::-1])
","34.96, 7.24","class Solution(object):
    def addBinary(self, a, b):
        """"""
        :type a: str
        :type b: str
        :rtype: str
        """"""
        carry = 0
        result = """"
        i, j = len(a) - 1, len(b) - 1
        
        while i >= 0 or j >= 0 or carry:
            digit_sum = carry
            if i >= 0:
                digit_sum += int(a[i])
                i -= 1
            if j >= 0:
                digit_sum += int(b[j])
                j -= 1
            result = str(digit_sum % 2) + result
            carry = digit_sum // 2
        
        return result
","7.85, 75.7","class Solution(object):
    def addBinary(self, a, b):
        """"""
        :type a: str
        :type b: str
        :rtype: str
        """"""
        carry = 0
        result = """"
        i, j = len(a) - 1, len(b) - 1
        
        while i >= 0 or j >= 0 or carry:
            digit_sum = carry
            if i >= 0:
                digit_sum += int(a[i])
                i -= 1
            if j >= 0:
                digit_sum += int(b[j])
                j -= 1
            result = str(digit_sum % 2) + result
            carry = digit_sum // 2
        
        return result
","32.54, 75.7",
18,Easy,1394,"class Solution(object):
    def findLucky(self, arr):
        frequency = {}
        
        # Count the frequency of each number in the array
        for num in arr:
            frequency[num] = frequency.get(num, 0) + 1
        
        lucky_numbers = []
        
        # Find the lucky numbers
        for num, freq in frequency.items():
            if num == freq:
                lucky_numbers.append(num)
        
        if not lucky_numbers:
            return -1
        
        return max(lucky_numbers)
",,,,,,,,,,,,"76.71, 97.95","from collections import Counter

class Solution(object):
    def findLucky(self, arr):
        frequency = Counter(arr)
        max_lucky = -1
        
        for num, freq in frequency.items():
            if num == freq:
                max_lucky = max(max_lucky, num)
        
        return max_lucky
","26.71, 97.95","class Solution(object):
    def findLucky(self, arr):
        frequency = [0] * 501  # Initialize frequency array
        
        # Count the frequency of each number in the array
        for num in arr:
            frequency[num] += 1
        
        max_lucky = -1
        
        # Find the maximum lucky number
        for num in range(1, len(frequency)):
            if num == frequency[num]:
                max_lucky = num
        
        return max_lucky
","56.85, 74.66","class Solution(object):
    def findLucky(self, arr):
        max_lucky = -1
        
        # Count the frequency of each number in the array
        for num in set(arr):
            freq = arr.count(num)
            if num == freq:
                max_lucky = max(max_lucky, num)
        
        return max_lucky
","36.30, 74.66","class Solution(object):
    def findLucky(self, arr):
        frequency = {}
        max_lucky = -1

        # Count the frequency of each number in the array
        for num in arr:
            frequency[num] = frequency.get(num, 0) + 1

            # Update the maximum lucky number if found
            if num == frequency[num]:
                max_lucky = max(max_lucky, num)

        return max_lucky
",,,,"Wrong Answer

77 / 101 testcases passed
Input
arr =
[2,2,2,3,3]
Use Testcase

Output
2
Expected
-1
"
19,Easy,2423,"class Solution(object):
    def equalFrequency(self, word):
        # Count the frequency of each letter
        freq = {}
        for char in word:
            freq[char] = freq.get(char, 0) + 1

        # Check if all frequencies are equal except one
        values = list(freq.values())
        target = values[0]
        count = 0
        for value in values:
            if value != target:
                count += 1
                if count > 1:
                    return False

        # If there is only one letter with a different frequency,
        # check if removing one occurrence makes all frequencies equal
        if count == 1:
            target_count = values.count(target)
            return target_count == 1 or target_count == len(values) - 1

        return True
","Wrong Answer

37 / 49 testcases passed
Input
word =
""aazz""
Use Testcase

Output
true
Expected
false
","class Solution(object):
    def equalFrequency(self, word):
        # Count the frequency of each letter
        freq = {}
        for char in word:
            freq[char] = freq.get(char, 0) + 1

        # Check if all frequencies are equal except one
        values = list(freq.values())
        target = values[0]
        count = 0
        for value in values:
            if value != target:
                count += 1
                if count > 1:
                    return False
            if count == 1 and value == 1:
                target = 1  # Update target frequency

        return True
","Wrong Answer

38 / 49 testcases passed
Input
word =
""aazz""
Use Testcase

Output
true
Expected
false


","class Solution(object):
    def equalFrequency(self, word):
        # Count the frequency of each letter
        freq = {}
        for char in word:
            freq[char] = freq.get(char, 0) + 1

        # Check if all frequencies are equal except one
        values = list(freq.values())
        max_freq = max(values)
        min_freq = min(values)
        if max_freq == min_freq:
            return True

        # Check if removing one occurrence can make all frequencies equal
        if values.count(max_freq) == 1 and max_freq - min_freq == 1:
            return True
        if values.count(min_freq) == 1 and min_freq == 1:
            return True

        return False
","Wrong Answer

43 / 49 testcases passed
Input
word =
""aazz""
Use Testcase

Output
true
Expected
false


","class Solution(object):
    def equalFrequency(self, word):
        # Count the frequency of each letter
        freq = {}
        for char in word:
            freq[char] = freq.get(char, 0) + 1

        # Count the frequency of frequencies
        freq_freq = {}
        for value in freq.values():
            freq_freq[value] = freq_freq.get(value, 0) + 1

        # Check if there is only one unique frequency and it meets the conditions
        if len(freq_freq) == 1:
            return True

        # Check if there are exactly two unique frequencies
        if len(freq_freq) == 2:
            min_freq, max_freq = sorted(freq_freq.keys())
            min_count, max_count = freq_freq.values()
            # Check if the difference between the frequencies is 1 and there is only one letter with the maximum frequency
            if max_freq - min_freq == 1 and max_count == 1:
                return True
            # Check if the minimum frequency is 1 and there is only one letter with the minimum frequency
            if min_freq == 1 and min_count == 1:
                return True

        return False
","Wrong Answer

47 / 49 testcases passed
Input
word =
""aazz""
Use Testcase

Output
true
Expected
false


","class Solution(object):
    def equalFrequency(self, word):
        # Count the frequency of each letter
        freq = {}
        for char in word:
            freq[char] = freq.get(char, 0) + 1

        # Count the frequency of frequencies
        freq_freq = {}
        for value in freq.values():
            freq_freq[value] = freq_freq.get(value, 0) + 1

        # Check if there is only one unique frequency and it meets the conditions
        if len(freq_freq) == 1:
            return True

        # Check if there are exactly two unique frequencies
        if len(freq_freq) == 2:
            min_freq = min(freq_freq.keys())
            max_freq = max(freq_freq.keys())
            min_count = freq_freq[min_freq]
            max_count = freq_freq[max_freq]
            # Check if the difference between the frequencies is 1 and there is only one letter with the maximum frequency
            if max_freq - min_freq == 1 and max_count == 1:
                return True
            # Check if the minimum frequency is 1 and there is only one letter with the minimum frequency
            if min_freq == 1 and min_count == 1:
                return True

        return False
","Wrong Answer

47 / 49 testcases passed
Input
word =
""aazz""
Use Testcase

Output
true
Expected
false


","class Solution(object):
    def equalFrequency(self, word):
        # Count the frequency of each letter
        freq = {}
        for char in word:
            freq[char] = freq.get(char, 0) + 1

        # Count the frequency of frequencies
        freq_freq = {}
        for value in freq.values():
            freq_freq[value] = freq_freq.get(value, 0) + 1

        # Check if there is only one unique frequency and it meets the conditions
        if len(freq_freq) == 1:
            return True

        # Check if there are exactly two unique frequencies
        if len(freq_freq) == 2:
            min_freq = min(freq_freq.keys())
            max_freq = max(freq_freq.keys())
            min_count = freq_freq[min_freq]
            max_count = freq_freq[max_freq]
            # Check if the difference between the frequencies is 1 and there is only one letter with the maximum frequency
            if max_count == 1 and max_freq - min_freq == 1:
                return True
            # Check if the minimum frequency is 1 and there is only one letter with the minimum frequency
            if min_count == 1 and min_freq == 1:
                return True

        return False
","Wrong Answer

47 / 49 testcases passed
Input
word =
""aazz""
Use Testcase

Output
true
Expected
false


",,,,,,,,,,,,
20,Easy,2413,"class Solution(object):
    def smallestEvenMultiple(self, n):
        if n % 2 == 0:
            return n
        else:
            return n * 2
",,,,,,,,,,,,"58.29, 28.68","class Solution(object):
    def smallestEvenMultiple(self, n):
        if n % 2 == 0:
            return n
        return n * 2
","18.44, 58.29","from math import gcd

class Solution(object):
    def smallestEvenMultiple(self, n):
        return (2 * n) // gcd(2, n)
",,,,,,,,"Runtime Error
0 / 150 testcases passed
ImportError: cannot import name gcd
    from math import gcd
Line 1 in <module> (Solution.py)
Last Executed Input
Use Testcase


n =
5

"
21,Medium,79,"class Solution(object):
    def exist(self, board, word):
        """"""
        :type board: List[List[str]]
        :type word: str
        :rtype: bool
        """"""
        def backtrack(board, word, i, j, index):
            # Base case: If all characters in the word have been found
            if index == len(word):
                return True
            
            # Check if the current position is out of bounds or the character doesn't match
            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[index]:
                return False
            
            # Temporarily mark the current position as visited
            temp = board[i][j]
            board[i][j] = '#'
            
            # Recursively check the neighboring cells
            found = (backtrack(board, word, i-1, j, index+1) or
                     backtrack(board, word, i+1, j, index+1) or
                     backtrack(board, word, i, j-1, index+1) or
                     backtrack(board, word, i, j+1, index+1))
            
            # Restore the original character and backtrack if the word is not found
            board[i][j] = temp
            
            return found
        
        # Iterate through each cell in the board to find the starting point for the word
        for i in range(len(board)):
            for j in range(len(board[0])):
                if backtrack(board, word, i, j, 0):
                    return True
        
        return False
",,,,,,,,,,,,"57.75, 93.43","class Solution(object):
    def exist(self, board, word):
        """"""
        :type board: List[List[str]]
        :type word: str
        :rtype: bool
        """"""
        def backtrack(board, word, i, j, index):
            # Base case: If all characters in the word have been found
            if index == len(word):
                return True
            
            # Check if the current position is out of bounds or the character doesn't match
            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[index]:
                return False
            
            # Temporarily mark the current position as visited
            temp = board[i][j]
            board[i][j] = '#'
            
            # Recursively check the neighboring cells
            found = (backtrack(board, word, i-1, j, index+1) or
                     backtrack(board, word, i+1, j, index+1) or
                     backtrack(board, word, i, j-1, index+1) or
                     backtrack(board, word, i, j+1, index+1))
            
            # Restore the original character
            board[i][j] = temp
            
            # If the word is found, no need to continue searching
            if found:
                return True
        
        # Iterate through each cell in the board to find the starting point for the word
        for i in range(len(board)):
            for j in range(len(board[0])):
                if backtrack(board, word, i, j, 0):
                    return True
        
        return False
","58.72, 77.91","class Solution(object):
    def exist(self, board, word):
        """"""
        :type board: List[List[str]]
        :type word: str
        :rtype: bool
        """"""
        def dfs(board, word, i, j, index):
            # Base case: If all characters in the word have been found
            if index == len(word):
                return True
            
            # Check if the current position is out of bounds or the character doesn't match
            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[index]:
                return False
            
            # Temporarily mark the current position as visited
            temp = board[i][j]
            board[i][j] = '#'
            
            # Explore the neighboring cells
            found = (dfs(board, word, i-1, j, index+1) or
                     dfs(board, word, i+1, j, index+1) or
                     dfs(board, word, i, j-1, index+1) or
                     dfs(board, word, i, j+1, index+1))
            
            # Restore the original character
            board[i][j] = temp
            
            return found
        
        # Iterate through each cell in the board to find the starting point for the word
        for i in range(len(board)):
            for j in range(len(board[0])):
                if dfs(board, word, i, j, 0):
                    return True
        
        return False
","60.66, 77.91","class TrieNode:
    def __init__(self):
        self.children = {}
        self.word = None

class Solution(object):
    def exist(self, board, word):
        """"""
        :type board: List[List[str]]
        :type word: str
        :rtype: bool
        """"""
        def build_trie(words):
            root = TrieNode()
            for word in words:
                node = root
                for char in word:
                    if char not in node.children:
                        node.children[char] = TrieNode()
                    node = node.children[char]
                node.word = word
            return root

        def backtrack(board, i, j, node):
            char = board[i][j]
            if char not in node.children:
                return

            node = node.children[char]
            if node.word:
                self.result = True
                return

            board[i][j] = '#'  # Mark as visited

            if i > 0:
                backtrack(board, i - 1, j, node)
            if i < len(board) - 1:
                backtrack(board, i + 1, j, node)
            if j > 0:
                backtrack(board, i, j - 1, node)
            if j < len(board[0]) - 1:
                backtrack(board, i, j + 1, node)

            board[i][j] = char  # Restore the character

        # Build the Trie from the given word list
        trie_root = build_trie([word])

        self.result = False

        # Iterate through each cell in the board to find the starting point for the word
        for i in range(len(board)):
            for j in range(len(board[0])):
                backtrack(board, i, j, trie_root)
                if self.result:
                    return True
        
        return False
","87.39, 93.43","class Solution(object):
    def exist(self, board, word):
        """"""
        :type board: List[List[str]]
        :type word: str
        :rtype: bool
        """"""
        def backtrack(board, word, i, j, index, memo):
            # Base case: If all characters in the word have been found
            if index == len(word):
                return True
            
            # Check if the current position is out of bounds or the character doesn't match
            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[index]:
                return False
            
            # Check if the solution for the current position has already been computed
            if memo[i][j]:
                return False
            
            # Temporarily mark the current position as visited
            temp = board[i][j]
            board[i][j] = '#'
            
            # Explore the neighboring cells
            found = (backtrack(board, word, i-1, j, index+1, memo) or
                     backtrack(board, word, i+1, j, index+1, memo) or
                     backtrack(board, word, i, j-1, index+1, memo) or
                     backtrack(board, word, i, j+1, index+1, memo))
            
            # Restore the original character
            board[i][j] = temp
            
            # Memoize the result for the current position
            memo[i][j] = found
            
            return found
        
        # Create a memoization grid to store computed results
        memo = [[False] * len(board[0]) for _ in range(len(board))]
        
        # Iterate through each cell in the board to find the starting point for the word
        for i in range(len(board)):
            for j in range(len(board[0])):
                if backtrack(board, word, i, j, 0, memo):
                    return True
        
        return False
","40.29, 55.6","class Solution(object):
    def exist(self, board, word):
        """"""
        :type board: List[List[str]]
        :type word: str
        :rtype: bool
        """"""
        def backtrack(board, word, i, j, index):
            # Base case: If all characters in the word have been found
            if index == len(word):
                return True
            
            # Check if the current position is out of bounds or the character doesn't match
            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[index]:
                return False
            
            # Temporarily mark the current position as visited
            temp = board[i][j]
            board[i][j] = '#'
            
            # Explore the neighboring cells
            found = (backtrack(board, word, i-1, j, index+1) or
                     backtrack(board, word, i+1, j, index+1) or
                     backtrack(board, word, i, j-1, index+1) or
                     backtrack(board, word, i, j+1, index+1))
            
            # Restore the original character
            board[i][j] = temp
            
            return found
        
        # Iterate through each cell in the board to find the starting point for the word
        for i in range(len(board)):
            for j in range(len(board[0])):
                if backtrack(board, word, i, j, 0):
                    return True
        
        return False
","61.41, 99.14",
22,Medium,962,"class Solution(object):
    def maxWidthRamp(self, nums):
        stack = []
        n = len(nums)
        
        # Find the indices of elements in decreasing order of their values
        for i in range(n):
            if not stack or nums[i] < nums[stack[-1]]:
                stack.append(i)
        
        # Find the maximum width ramp
        max_width = 0
        for j in range(n - 1, -1, -1):
            while stack and nums[j] >= nums[stack[-1]]:
                max_width = max(max_width, j - stack.pop())
            
        return max_width
",,,,,,,,,,,,"58.82, 23.53","class Solution(object):
    def maxWidthRamp(self, nums):
        n = len(nums)
        max_width = 0
        
        # Create a sorted list of indices based on the element values
        indices = sorted(range(n), key=lambda x: nums[x])
        
        min_index = n
        for i in indices:
            # Update the minimum index encountered so far
            min_index = min(min_index, i)
            
            # Calculate the width ramp using the current index and the minimum index
            width = i - min_index
            
            # Update the maximum width ramp
            max_width = max(max_width, width)
        
        return max_width
","35.29, 23.53","class Solution(object):
    def maxWidthRamp(self, nums):
        stack = []
        n = len(nums)
        
        # Build the stack in decreasing order of nums elements
        for i in range(n):
            if not stack or nums[i] < nums[stack[-1]]:
                stack.append(i)
        
        max_width = 0
        
        # Iterate from right to left to find the maximum width ramp
        for j in range(n - 1, -1, -1):
            while stack and nums[j] >= nums[stack[-1]]:
                max_width = max(max_width, j - stack.pop())
        
        return max_width
","58.82, 70.59","class Solution(object):
    def maxWidthRamp(self, nums):
        n = len(nums)
        
        # Create a list of tuples (value, index) for each element in nums
        nums_with_indices = [(nums[i], i) for i in range(n)]
        
        # Sort nums_with_indices in ascending order of values
        nums_with_indices.sort()
        
        max_width = 0
        min_index = n
        
        # Iterate through nums_with_indices and update max_width
        for _, index in nums_with_indices:
            max_width = max(max_width, index - min_index)
            min_index = min(min_index, index)
        
        return max_width
","17.65, 5.88","class Solution(object):
    def maxWidthRamp(self, nums):
        n = len(nums)
        indices = list(range(n))
        
        # Sort indices based on nums using a modified merge sort
        indices.sort(key=lambda x: nums[x])
        
        max_width = 0
        min_index = n
        
        # Iterate through the sorted indices and update max_width
        for index in indices:
            max_width = max(max_width, index - min_index)
            min_index = min(min_index, index)
        
        return max_width
","23.53, 23.53","class Solution(object):
    def maxWidthRamp(self, nums):
        n = len(nums)
        max_width = 0
        min_index = float('inf')
        
        # Find the minimum index for each value in nums
        for i, num in enumerate(nums):
            if num < nums[min_index]:
                min_index = i
        
        # Calculate the maximum width ramp
        for j in range(n-1, -1, -1):
            if nums[j] >= nums[min_index]:
                max_width = max(max_width, j - min_index)
            else:
                min_index = j
        
        return max_width
",,"Runtime Error
0 / 98 testcases passed
TypeError: list indices must be integers, not float
    if num < nums[min_index]:
Line 9 in maxWidthRamp (Solution.py)
    ret = Solution().maxWidthRamp(param_1)
Line 39 in _driver (Solution.py)
    _driver()
Line 49 in <module> (Solution.py)
Last Executed Input
Use Testcase


nums =
[6,0,8,2,1,5]

"
23,Medium,820,"class Solution(object):
    def minimumLengthEncoding(self, words):
        word_set = set(words)
        result = 0

        for word in word_set:
            for i in range(1, len(word)):
                suffix = word[i:]
                if suffix in word_set:
                    break
            else:
                result += len(word) + 1

        return result
","Wrong Answer

23 / 38 testcases passed
Input
words =
[""time"",""me"",""bell""]
Use Testcase

Output
8
Expected
10
","class Solution(object):
    def minimumLengthEncoding(self, words):
        word_set = set(words)
        result = 0

        for word in words:
            for i in range(1, len(word)):
                suffix = word[i:]
                if suffix in word_set:
                    word_set.remove(suffix)

        for word in word_set:
            result += len(word) + 1

        return result
",,,,,,,,,,"75, 100","class Solution(object):
    def minimumLengthEncoding(self, words):
        word_set = set(words)
        suffixes = set()

        for word in word_set:
            for i in range(1, len(word)):
                suffix = word[i:]
                suffixes.add(suffix)

        for word in word_set:
            if word in suffixes:
                suffixes.remove(word)

        result = sum(len(word) + 1 for word in word_set if word not in suffixes)
        return result
",,,,,,,,,,"Wrong Answer

23 / 38 testcases passed
Input
words =
[""time"",""me"",""bell""]
Use Testcase

Output
13
Expected
10


"
24,Medium,1034,"class Solution(object):
    def colorBorder(self, grid, row, col, color):
        m, n = len(grid), len(grid[0])
        original_color = grid[row][col]
        visited = set()

        def dfs(i, j):
            if (
                i < 0
                or i >= m
                or j < 0
                or j >= n
                or grid[i][j] != original_color
                or (i, j) in visited
            ):
                return False

            visited.add((i, j))

            if (
                i == 0
                or i == m - 1
                or j == 0
                or j == n - 1
                or grid[i - 1][j] != original_color
                or grid[i + 1][j] != original_color
                or grid[i][j - 1] != original_color
                or grid[i][j + 1] != original_color
            ):
                grid[i][j] = color

            return (
                dfs(i - 1, j)
                or dfs(i + 1, j)
                or dfs(i, j - 1)
                or dfs(i, j + 1)
            )

        dfs(row, col)
        return grid
","Wrong Answer

147 / 154 testcases passed
Input
grid =
[[1,2,1,2,1,2],[2,2,2,2,1,2],[1,2,2,2,1,2]]
row =
1
col =
3
color =
1
Use Testcase

Output
[[1,1,1,1,1,2],[1,1,1,1,1,2],[1,1,1,1,1,2]]
Expected
[[1,1,1,1,1,2],[1,2,1,1,1,2],[1,1,1,1,1,2]]


","class Solution(object):
    def colorBorder(self, grid, row, col, color):
        m, n = len(grid), len(grid[0])
        original_color = grid[row][col]
        visited = set()

        def dfs(i, j):
            if (
                i < 0
                or i >= m
                or j < 0
                or j >= n
                or grid[i][j] != original_color
                or (i, j) in visited
            ):
                return False

            visited.add((i, j))

            is_border = (
                i == 0
                or i == m - 1
                or j == 0
                or j == n - 1
                or grid[i - 1][j] != original_color
                or grid[i + 1][j] != original_color
                or grid[i][j - 1] != original_color
                or grid[i][j + 1] != original_color
            )

            if is_border:
                grid[i][j] = color

            return (
                dfs(i - 1, j)
                or dfs(i + 1, j)
                or dfs(i, j - 1)
                or dfs(i, j + 1)
            )

        dfs(row, col)
        return grid
","Wrong Answer

147 / 154 testcases passed
Input
grid =
[[1,2,1,2,1,2],[2,2,2,2,1,2],[1,2,2,2,1,2]]
row =
1
col =
3
color =
1
Use Testcase

Output
[[1,1,1,1,1,2],[1,1,1,1,1,2],[1,1,1,1,1,2]]
Expected
[[1,1,1,1,1,2],[1,2,1,1,1,2],[1,1,1,1,1,2]]
","class Solution(object):
    def colorBorder(self, grid, row, col, color):
        m, n = len(grid), len(grid[0])
        original_color = grid[row][col]
        visited = set()

        def dfs(i, j):
            if (
                i < 0
                or i >= m
                or j < 0
                or j >= n
                or grid[i][j] != original_color
                or (i, j) in visited
            ):
                return False

            visited.add((i, j))

            is_border = (
                i == 0
                or i == m - 1
                or j == 0
                or j == n - 1
                or grid[i - 1][j] != original_color
                or grid[i + 1][j] != original_color
                or grid[i][j - 1] != original_color
                or grid[i][j + 1] != original_color
            )

            if is_border:
                grid[i][j] = color

            return (
                dfs(i - 1, j)
                or dfs(i + 1, j)
                or dfs(i, j - 1)
                or dfs(i, j + 1)
            )

        dfs(row, col)

        for i in range(m):
            for j in range(n):
                if grid[i][j] == -1:
                    grid[i][j] = original_color

        return grid
","Wrong Answer

147 / 154 testcases passed
Input
grid =
[[1,2,1,2,1,2],[2,2,2,2,1,2],[1,2,2,2,1,2]]
row =
1
col =
3
color =
1
Use Testcase

Output
[[1,1,1,1,1,2],[1,1,1,1,1,2],[1,1,1,1,1,2]]
Expected
[[1,1,1,1,1,2],[1,2,1,1,1,2],[1,1,1,1,1,2]]
","class Solution(object):
    def colorBorder(self, grid, row, col, color):
        m, n = len(grid), len(grid[0])
        original_color = grid[row][col]
        visited = set()

        def dfs(i, j):
            if (
                i < 0
                or i >= m
                or j < 0
                or j >= n
                or grid[i][j] != original_color
                or (i, j) in visited
            ):
                return False

            visited.add((i, j))

            is_border = (
                i == 0
                or i == m - 1
                or j == 0
                or j == n - 1
                or grid[i - 1][j] != original_color
                or grid[i + 1][j] != original_color
                or grid[i][j - 1] != original_color
                or grid[i][j + 1] != original_color
            )

            if is_border:
                grid[i][j] = -original_color

            return (
                dfs(i - 1, j)
                or dfs(i + 1, j)
                or dfs(i, j - 1)
                or dfs(i, j + 1)
            )

        dfs(row, col)

        for i in range(m):
            for j in range(n):
                if grid[i][j] == -original_color:
                    grid[i][j] = color

        return grid
","Wrong Answer

147 / 154 testcases passed
Input
grid =
[[1,2,1,2,1,2],[2,2,2,2,1,2],[1,2,2,2,1,2]]
row =
1
col =
3
color =
1
Use Testcase

Output
[[1,1,1,1,1,2],[1,1,1,1,1,2],[1,1,1,1,1,2]]
Expected
[[1,1,1,1,1,2],[1,2,1,1,1,2],[1,1,1,1,1,2]]
","class Solution(object):
    def colorBorder(self, grid, row, col, color):
        m, n = len(grid), len(grid[0])
        original_color = grid[row][col]
        visited = set()

        def dfs(i, j):
            if (
                i < 0
                or i >= m
                or j < 0
                or j >= n
                or grid[i][j] != original_color
                or (i, j) in visited
            ):
                return False

            visited.add((i, j))

            is_border = (
                i == 0
                or i == m - 1
                or j == 0
                or j == n - 1
                or grid[i - 1][j] != original_color
                or grid[i + 1][j] != original_color
                or grid[i][j - 1] != original_color
                or grid[i][j + 1] != original_color
            )

            if is_border:
                grid[i][j] = -original_color

            return (
                dfs(i - 1, j)
                or dfs(i + 1, j)
                or dfs(i, j - 1)
                or dfs(i, j + 1)
            )

        dfs(row, col)

        for i in range(m):
            for j in range(n):
                if grid[i][j] < 0:
                    grid[i][j] = color

        return grid
","Wrong Answer

147 / 154 testcases passed
Input
grid =
[[1,2,1,2,1,2],[2,2,2,2,1,2],[1,2,2,2,1,2]]
row =
1
col =
3
color =
1
Use Testcase

Output
[[1,1,1,1,1,2],[1,1,1,1,1,2],[1,1,1,1,1,2]]
Expected
[[1,1,1,1,1,2],[1,2,1,1,1,2],[1,1,1,1,1,2]]
","class Solution(object):
    def colorBorder(self, grid, row, col, color):
        m, n = len(grid), len(grid[0])
        original_color = grid[row][col]
        visited = set()

        def dfs(i, j):
            if (
                i < 0
                or i >= m
                or j < 0
                or j >= n
                or grid[i][j] != original_color
                or (i, j) in visited
            ):
                return False

            visited.add((i, j))

            is_border = (
                i == 0
                or i == m - 1
                or j == 0
                or j == n - 1
                or grid[i - 1][j] != original_color
                or grid[i + 1][j] != original_color
                or grid[i][j - 1] != original_color
                or grid[i][j + 1] != original_color
            )

            if is_border:
                grid[i][j] = -original_color

            return (
                dfs(i - 1, j)
                or dfs(i + 1, j)
                or dfs(i, j - 1)
                or dfs(i, j + 1)
            )

        dfs(row, col)

        for i in range(m):
            for j in range(n):
                if grid[i][j] < 0:
                    grid[i][j] = color
                elif grid[i][j] == -original_color:
                    grid[i][j] = original_color

        return grid
","Wrong Answer

147 / 154 testcases passed
Input
grid =
[[1,2,1,2,1,2],[2,2,2,2,1,2],[1,2,2,2,1,2]]
row =
1
col =
3
color =
1
Use Testcase

Output
[[1,1,1,1,1,2],[1,1,1,1,1,2],[1,1,1,1,1,2]]
Expected
[[1,1,1,1,1,2],[1,2,1,1,1,2],[1,1,1,1,1,2]]
",,,,,,,,,,,,
25,Medium,1625,"class Solution(object):
    def findLexSmallestString(self, s, a, b):
        """"""
        :type s: str
        :type a: int
        :type b: int
        :rtype: str
        """"""
        n = len(s)
        visited = set()
        queue = [s]

        while queue:
            curr = queue.pop(0)
            visited.add(curr)

            # Apply the rotation operation
            rotated = curr[-b:] + curr[:-b]
            if rotated not in visited:
                queue.append(rotated)

            # Apply the addition operation
            added = list(curr)
            for i in range(1, n, 2):
                digit = int(curr[i])
                digit = (digit + a) % 10
                added[i] = str(digit)
                joined = ''.join(added)
                if joined not in visited:
                    queue.append(joined)

        return min(visited)
","Time Limit Exceeded
3 / 80 testcases passed
Last Executed Input
Use Testcase

s =
""43987654""
a =
7

b =
3

","class Solution(object):
    def findLexSmallestString(self, s, a, b):
        """"""
        :type s: str
        :type a: int
        :type b: int
        :rtype: str
        """"""
        n = len(s)
        visited = set()
        queue = [s]

        while queue:
            curr = queue.pop(0)
            visited.add(curr)

            # Apply the rotation operation
            rotated = curr[-b:] + curr[:-b]
            if rotated not in visited and rotated not in queue:
                queue.append(rotated)

            # Apply the addition operation
            added = list(curr)
            for i in range(1, n, 2):
                digit = int(curr[i])
                digit = (digit + a) % 10
                added[i] = str(digit)
                joined = ''.join(added)
                if joined not in visited and joined not in queue:
                    queue.append(joined)

        return min(visited)
","Time Limit Exceeded
3 / 80 testcases passed
Last Executed Input
Use Testcase

s =
""43987654""
a =
7

b =
3
","class Solution(object):
    def findLexSmallestString(self, s, a, b):
        """"""
        :type s: str
        :type a: int
        :type b: int
        :rtype: str
        """"""
        n = len(s)
        visited = set()
        self.result = s

        def dfs(string):
            visited.add(string)
            if string < self.result:
                self.result = string

            rotated = string[-b:] + string[:-b]
            added = list(string)
            for i in range(1, n, 2):
                digit = int(string[i])
                digit = (digit + a) % 10
                added[i] = str(digit)
            joined = ''.join(added)

            if rotated not in visited:
                dfs(rotated)
            if joined not in visited:
                dfs(joined)

        dfs(s)
        return self.result
",,,,,,,,"100, 20","class Solution(object):
    def findLexSmallestString(self, s, a, b):
        """"""
        :type s: str
        :type a: int
        :type b: int
        :rtype: str
        """"""
        n = len(s)
        visited = set()
        queue = [s]
        result = s

        while queue:
            curr = queue.pop(0)
            visited.add(curr)

            if curr < result:
                result = curr

            # Apply the rotation operation
            rotated = curr[-b:] + curr[:-b]
            if rotated not in visited:
                queue.append(rotated)

            # Apply the addition operation
            added = list(curr)
            for i in range(1, n, 2):
                digit = int(curr[i])
                digit = (digit + a) % 10
                added[i] = str(digit)
            joined = ''.join(added)

            if joined not in visited:
                queue.append(joined)

            # Optimization: Apply rotation before addition
            if b % 2 == 1 and a % 2 == 1:
                rotated_added = joined[-b:] + joined[:-b]
                if rotated_added not in visited:
                    queue.append(rotated_added)

        return result
",,,,,,,,,,"Time Limit Exceeded
3 / 80 testcases passed
Last Executed Input
Use Testcase

s =
""43987654""
a =
7

b =
3

"
26,Medium,95,"# Definition for a binary tree node.
class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution(object):
    def generateTrees(self, n):
        """"""
        :type n: int
        :rtype: List[TreeNode]
        """"""
        if n == 0:
            return []
        
        def generate_trees(start, end):
            if start > end:
                return [None]
            
            all_trees = []
            for i in range(start, end+1):
                left_trees = generate_trees(start, i-1)
                right_trees = generate_trees(i+1, end)
                
                for left in left_trees:
                    for right in right_trees:
                        current_tree = TreeNode(i)
                        current_tree.left = left
                        current_tree.right = right
                        all_trees.append(current_tree)
            
            return all_trees
        
        return generate_trees(1, n)
",,,,,,,,,,,,"51.35, 79.5","# Definition for a binary tree node.
class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution(object):
    def generateTrees(self, n):
        """"""
        :type n: int
        :rtype: List[TreeNode]
        """"""
        if n == 0:
            return []
        
        def generate_trees(start, end, memo):
            if start > end:
                return [None]
            
            if (start, end) in memo:
                return memo[(start, end)]
            
            all_trees = []
            for i in range(start, end+1):
                left_trees = generate_trees(start, i-1, memo)
                right_trees = generate_trees(i+1, end, memo)
                
                for left in left_trees:
                    for right in right_trees:
                        current_tree = TreeNode(i)
                        current_tree.left = left
                        current_tree.right = right
                        all_trees.append(current_tree)
            
            memo[(start, end)] = all_trees
            return all_trees
        
        memo = {}
        return generate_trees(1, n, memo)
","25, 95.27","# Definition for a binary tree node.
class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution(object):
    def generateTrees(self, n):
        """"""
        :type n: int
        :rtype: List[TreeNode]
        """"""
        if n == 0:
            return []
        
        dp = [[] for _ in range(n + 1)]
        dp[0].append(None)
        
        for length in range(1, n + 1):
            for root_val in range(1, length + 1):
                left_length = root_val - 1
                right_length = length - root_val
                
                for left_tree in dp[left_length]:
                    for right_tree in dp[right_length]:
                        root = TreeNode(root_val)
                        root.left = self.clone_tree(left_tree, 0)
                        root.right = self.clone_tree(right_tree, root_val)
                        dp[length].append(root)
        
        return dp[n]
    
    def clone_tree(self, node, offset):
        if node is None:
            return None
        
        new_node = TreeNode(node.val + offset)
        new_node.left = self.clone_tree(node.left, offset)
        new_node.right = self.clone_tree(node.right, offset)
        
        return new_node
","6.76, 5.41","# Definition for a binary tree node.
class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution(object):
    def generateTrees(self, n):
        """"""
        :type n: int
        :rtype: List[TreeNode]
        """"""
        def generate_trees(start, end, memo):
            if start > end:
                return [None]
            
            if (start, end) in memo:
                return memo[(start, end)]
            
            all_trees = []
            for i in range(start, end+1):
                left_trees = generate_trees(start, i-1, memo)
                right_trees = generate_trees(i+1, end, memo)
                
                for left in left_trees:
                    for right in right_trees:
                        root = TreeNode(i)
                        root.left = left
                        root.right = right
                        all_trees.append(root)
            
            memo[(start, end)] = all_trees
            return all_trees
        
        if n == 0:
            return []
        
        memo = {}
        return generate_trees(1, n, memo)
","97.97, 97.30","# Definition for a binary tree node.
class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution(object):
    def generateTrees(self, n):
        """"""
        :type n: int
        :rtype: List[TreeNode]
        """"""
        def generate_trees(start, end):
            if start > end:
                return [None]
            
            all_trees = []
            for i in range(start, end+1):
                left_trees = generate_trees(start, i-1)
                right_trees = generate_trees(i+1, end)
                
                for left in left_trees:
                    for right in right_trees:
                        root = TreeNode(i)
                        root.left = left
                        root.right = right
                        all_trees.append(root)
            
            return all_trees
        
        if n == 0:
            return []
        
        return generate_trees(1, n)
","59.46, 79.5","# Definition for a binary tree node.
class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution(object):
    def generateTrees(self, n):
        """"""
        :type n: int
        :rtype: List[TreeNode]
        """"""
        if n == 0:
            return []
        
        def generate_trees(start, end, memo):
            if start > end:
                return [None]
            
            if (start, end) in memo:
                return memo[(start, end)]
            
            all_trees = []
            for i in range(start, end+1):
                left_trees = generate_trees(start, i-1, memo)
                right_trees = generate_trees(i+1, end, memo)
                
                for left in left_trees:
                    for right in right_trees:
                        root = TreeNode(i)
                        root.left = left
                        root.right = right
                        all_trees.append(root)
            
            memo[(start, end)] = all_trees
            return all_trees
        
        memo = {}
        return generate_trees(1, n, memo)
","92.57, 92.57",
27,Medium,955,"class Solution(object):
    def minDeletionSize(self, strs):
        """"""
        :type strs: List[str]
        :rtype: int
        """"""
        rows = len(strs)
        cols = len(strs[0])
        deletion_count = 0

        for col in range(cols):
            for row in range(1, rows):
                if strs[row][col] < strs[row - 1][col]:
                    deletion_count += 1
                    break

        return deletion_count
","Wrong Answer

8 / 147 testcases passed
Input
strs =
[""xc"",""yb"",""za""]
Use Testcase

Output
1
Expected
0


","class Solution(object):
    def minDeletionSize(self, strs):
        """"""
        :type strs: List[str]
        :rtype: int
        """"""
        rows = len(strs)
        cols = len(strs[0])
        deletion_count = 0

        for col in range(cols):
            for row in range(1, rows):
                if strs[row][col] < strs[row - 1][col]:
                    deletion_count += 1
                    break

        return deletion_count
","Wrong Answer

8 / 147 testcases passed
Input
strs =
[""xc"",""yb"",""za""]
Use Testcase

Output
1
Expected
0


","class Solution(object):
    def minDeletionSize(self, strs):
        """"""
        :type strs: List[str]
        :rtype: int
        """"""
        deletion_count = 0

        for col in range(len(strs[0])):
            for row in range(1, len(strs)):
                if strs[row][col] < strs[row - 1][col]:
                    deletion_count += 1
                    break

        return deletion_count
","Wrong Answer

8 / 147 testcases passed
Input
strs =
[""xc"",""yb"",""za""]
Use Testcase

Output
1
Expected
0


","class Solution(object):
    def minDeletionSize(self, strs):
        """"""
        :type strs: List[str]
        :rtype: int
        """"""
        deletion_count = 0

        for col in range(len(strs[0])):
            for row in range(1, len(strs)):
                if strs[row][col] < strs[row - 1][col]:
                    deletion_count += 1
                    break
            else:
                continue
            break

        return deletion_count
","Wrong Answer

28 / 147 testcases passed
Input
strs =
[""xc"",""yb"",""za""]
Use Testcase

Output
1
Expected
0


","class Solution(object):
    def minDeletionSize(self, strs):
        """"""
        :type strs: List[str]
        :rtype: int
        """"""
        deletion_count = 0

        for col in range(len(strs[0])):
            column = [strs[row][col] for row in range(len(strs))]
            if column != sorted(column):
                deletion_count += 1

        return deletion_count
","Wrong Answer

8 / 147 testcases passed
Input
strs =
[""xc"",""yb"",""za""]
Use Testcase

Output
1
Expected
0


","class Solution(object):
    def minDeletionSize(self, strs):
        """"""
        :type strs: List[str]
        :rtype: int
        """"""
        deletion_count = 0

        for col in range(len(strs[0])):
            for row in range(1, len(strs)):
                if strs[row][col] < strs[row - 1][col]:
                    deletion_count += 1
                    break

        return deletion_count
","Wrong Answer

8 / 147 testcases passed
Input
strs =
[""xc"",""yb"",""za""]
Use Testcase

Output
1
Expected
0


",,,,,,,,,,,,
28,Medium,1395,"class Solution(object):
    def numTeams(self, rating):
        """"""
        :type rating: List[int]
        :rtype: int
        """"""
        n = len(rating)
        count = 0

        for i in range(n - 2):
            for j in range(i + 1, n - 1):
                for k in range(j + 1, n):
                    if (rating[i] < rating[j] < rating[k]) or (rating[i] > rating[j] > rating[k]):
                        count += 1

        return count
","Time Limit Exceeded
60 / 72 testcases passed
Last Executed Input
Use Testcase

rating =
[2173,478,1128,2138,785,159,819,2747,557,2422,2092,1105,1374,2450,1574,951,1290,1590,1929,1605,1646,2791,2701,2911,971,2066,493,1593,1537,257,205,1109,79,470,1790,221,180,1891,250,1798,75,2778,2302,1299,923,355,2399,2536,2628,2805,1046,1555,2178,2722,1843,754,1908,610,2933,613,2047,2296,2820,1815,2997,431,1320,11,1387,227,913,2530,1680,2136,2589,2027,2003,2699,1271,1831,666,1872,1268,62,399,1665,1508,2228,2079,1418,1937,2686,1429,58,1696,161,2476,1950,857,699,2792,1353,2901,2923,330,99,1711,2546,2405,1340,2456,664,2584,2741,60,488,2406,1988,1827,1514,1708,2043,513,789,1284,2132,1600,646,2660,552,2139,507,1256,374,1655,1899,2295,288,2606,1874,776,2361,1958,751,2759,386,438,644,1954,2788,2081,832,2230,2602,2222,919,2905,694,2793,2562,2867,1169,1732,1381,2462,1230,284,1624,2496,748,2107,385,1064,1267,2058,499,2203,215,88,585,525,1136,309,1851,2085,109,2809,517,409,2419,2384,2308,2292,1994,2943,1294,1781,1862,2841,2096,662,2014,2426,2821,2400,113,129,2193,2865,618,121,1038,1782,2468,2861,234,249,2967,1533,607,1453,1465,477,471,1778,2143,1050,1728,1332,1967,73,1698,626,1449,2833,2447,917,2500,1920,673,1234,1420,1659,880,584,2023,1281,1544,1380,2019,2131,1018,152,2268,2052,2372,1017,2807,1424,633,1726,523,373,2850,1025,2371,1405,2252,996,895,1475,1886,2002,1720,1826,381,1835,1666,2879,2255,182,2641,2680,2920,1336,2061,1969,394,858,480,2322,766,1176,2995,1691,681,2595,1758,745,2492,1212,2776,1177,1027,448,2866,2423,2156,701,1184,2294,612,1963,2928,2851,875,949,814,244,2930,2306,2515,1266,522,830,2364,2209,1168,1372,686,325,354,511,1860,2828,1504,2176,1189,2694,1838,392,594,1091,1183,368,862,1457,2191,1096,410,177,274,2033,5,1697,1573,504,2725,2859,2401,2122,1118,813,936,455,1115,671,690,1067,144,155,2060,1998,2242,1978,566,624,518,2086,76,1526,2219,2618,2180,2880,1301,166,2153,2202,944,2346,196,720,2529,1945,2772,1441,2715,2366,1578,838,464,194,1645,1020,1042,2474,1060,1314,1207,1245,890,2057,643,2540,2094,1529,932,2563,545,1153,803,1742,1102,2351,370,1369,1973,1837,2250,2121,178,266,521,2259,1850,2964,1964,726,1743,2410,716,2118,1265,2542,878,1924,532,812,2487,1417,2262,321,920,2217,497,1875,555,2662,898,1404,2408,253,65,1916,2486,445,797,1765,1376,1470,2181,2856,2554,2045,1415,2858,1842,248,1810,596,453,1816,1802,1517,397,760,2324,1930,2522,2216,736,297,2755,107,2110,2965,755,1261,2415,1395,1016,809,2913,1779,55,2297,1637,2691,67,1983,185,2080,656,1014,1795,2220,1024,2658,1610,361,2800,2448,1174,2425,1479,256,2605,2320,1832,1991,588,1019,2317,278,727,242,2586,1431,371,2293,1371,1445,2864,2548,773,1615,1868,582,2692,589,1489,2009,1905,2831,2084,2104,138,1580,446,389,847,2028,1262,68,889,1767,907,989,1152,203,2089,2328,417,1248,2843,1451,1972,1409,1519,2455,2383,943,683,108,2395,1773,2356,2337,839,1717,1777,1757,2115,2925,1430,1933,1005,2736,2958,1295,307,1028,597,739,51,157,2375,933,2385,292,905,280,893,1315,2323,1562,2435,1746,2090,985,420,2742,2949,304,842,1487,520,1556,2862,684,711,271,1283,2166,2545,425,429,1497]
","class Solution(object):
    def numTeams(self, rating):
        """"""
        :type rating: List[int]
        :rtype: int
        """"""
        count = 0
        n = len(rating)

        for j in range(1, n - 1):
            left_smaller = left_larger = right_smaller = right_larger = 0

            for i in range(j):
                if rating[i] < rating[j]:
                    left_smaller += 1
                elif rating[i] > rating[j]:
                    left_larger += 1

            for k in range(j + 1, n):
                if rating[k] < rating[j]:
                    right_smaller += 1
                elif rating[k] > rating[j]:
                    right_larger += 1

            count += left_smaller * right_larger + left_larger * right_smaller

        return count
",,,,,,,,,,"46.67, 33.33","class Solution(object):
    def numTeams(self, rating):
        """"""
        :type rating: List[int]
        :rtype: int
        """"""
        count = 0
        n = len(rating)

        for j in range(1, n - 1):
            left_smaller = left_larger = right_smaller = right_larger = 0

            for i in range(j):
                if rating[i] < rating[j]:
                    left_smaller += 1
                elif rating[i] > rating[j]:
                    left_larger += 1

            for k in range(j + 1, n):
                if rating[k] < rating[j]:
                    right_smaller += 1
                elif rating[k] > rating[j]:
                    right_larger += 1

            count += left_smaller * right_larger + left_larger * right_smaller

        return count
","46.67, 100","class Solution(object):
    def numTeams(self, rating):
        """"""
        :type rating: List[int]
        :rtype: int
        """"""
        count = 0
        n = len(rating)

        for j in range(1, n - 1):
            left_smaller = left_larger = right_smaller = right_larger = 0

            for i in range(j):
                if rating[i] < rating[j]:
                    left_smaller += 1
                elif rating[i] > rating[j]:
                    left_larger += 1

            for k in range(j + 1, n):
                if rating[k] < rating[j]:
                    right_smaller += 1
                elif rating[k] > rating[j]:
                    right_larger += 1

            count += left_smaller * right_larger + left_larger * right_smaller

        return count
","43.33, 86.67","class Solution(object):
    def numTeams(self, rating):
        """"""
        :type rating: List[int]
        :rtype: int
        """"""
        count = 0
        n = len(rating)

        for i in range(n - 2):
            left_smaller = left_larger = 0

            for j in range(i + 1, n - 1):
                if rating[i] < rating[j]:
                    left_smaller += 1
                else:
                    left_larger += 1

            right_smaller = right_larger = 0
            for k in range(i + 2, n):
                if rating[k] < rating[i + 1]:
                    right_smaller += 1
                else:
                    right_larger += 1

            count += (left_smaller * right_larger) + (left_larger * right_smaller)

        return count
",,,,,,"Wrong Answer

5 / 72 testcases passed
Input
rating =
[2,5,3,4,1]
Use Testcase

Output
2
Expected
3


"
29,Medium,837,"class Solution(object):
    def new21Game(self, n, k, maxPts):
        if k == 0 or n >= k + maxPts:
            return 1.0
        
        dp = [0.0] * (n + 1)
        dp[0] = 1.0
        window_sum = 1.0
        
        for i in range(1, n + 1):
            dp[i] = window_sum / maxPts
            if i < k:
                window_sum += dp[i]
            if i - maxPts >= 0:
                window_sum -= dp[i - maxPts]
        
        return sum(dp[k:])
",,,,,,,,,,,,"100, 16.67","class Solution(object):
    def new21Game(self, n, k, maxPts):
        if k == 0 or n >= k + maxPts:
            return 1.0
        
        dp = [0.0] * (n + 1)
        dp[0] = 1.0
        window_sum = 1.0
        
        for i in range(1, n + 1):
            dp[i] = window_sum / maxPts
            if i < k:
                window_sum += dp[i]
            if i - maxPts >= 0:
                window_sum -= dp[i - maxPts]
        
        return sum(dp[k:])
","50, 50","class Solution(object):
    def new21Game(self, n, k, maxPts):
        if k == 0 or n >= k + maxPts:
            return 1.0
        
        dp = [0.0] * (k + maxPts)
        dp[0] = 1.0
        window_sum = 1.0
        
        for i in range(1, k + maxPts):
            dp[i] = window_sum / maxPts
            if i < k:
                window_sum += dp[i]
            if i - maxPts >= 0:
                window_sum -= dp[i - maxPts]
        
        return sum(dp[k:])
",,,,,,,,"Wrong Answer

40 / 151 testcases passed
Input
n =
6
k =
1
maxPts =
10
Use Testcase

Output
1.00000
Expected
0.60000


"
30,Medium,1762,"class Solution(object):
    def findBuildings(self, heights):
        ocean_view_buildings = []
        max_height = 0

        # Traverse the buildings from right to left
        for i in range(len(heights)-1, -1, -1):
            # Check if the current building has an ocean view
            if heights[i] > max_height:
                ocean_view_buildings.append(i)
                max_height = heights[i]

        # Reverse the order of the ocean view buildings to obtain the increasing order
        return ocean_view_buildings[::-1]
",,,,,,,,,,,,"39.8, 56.12","class Solution(object):
    def findBuildings(self, heights):
        res = []
        max_height = 0

        # Traverse the buildings from right to left
        for i in range(len(heights)-1, -1, -1):
            # Check if the current building has an ocean view
            if heights[i] > max_height:
                res.append(i)
                max_height = heights[i]

        # Return the result in increasing order
        return res[::-1]
","42.86, 70.41","class Solution(object):
    def findBuildings(self, heights):
        res = []
        max_height = 0

        # Traverse the buildings from left to right
        for i in range(len(heights)):
            # Check if the current building has an ocean view
            if heights[i] > max_height:
                res.append(i)
                max_height = heights[i]

        return res
",,,,,,,,"Wrong Answer

1 / 77 testcases passed
Input
heights =
[4,2,3,1]
Use Testcase

Output
[0]
Expected
[0,2,3]


"
31,Medium,1227,"class Solution(object):
    def nthPersonGetsNthSeat(self, n):
        memo = [-1.0] * (n+1)  # Memoization table
        
        def helper(n):
            if n == 1:
                return 1.0
            elif n == 2:
                return 0.5
            elif memo[n] != -1.0:
                return memo[n]
            else:
                result = 0.5 * (helper(n-2) + helper(n-1))
                memo[n] = result
                return result
        
        return helper(n)
","Wrong Answer

2 / 100 testcases passed
Input
n =
3
Use Testcase

Output
0.75000
Expected
0.50000
","class Solution(object):
    def nthPersonGetsNthSeat(self, n):
        if n == 1:
            return 1.0
        else:
            return 0.5 + 0.5 * self.nthPersonGetsNthSeat(n-1)
","Wrong Answer

1 / 100 testcases passed
Input
n =
2
Use Testcase

Output
1.00000
Expected
0.50000
","class Solution(object):
    def nthPersonGetsNthSeat(self, n):
        if n == 1:
            return 1.0
        else:
            return 0.5
",,,,,,,,"39.29, 60.71","class Solution(object):
    def nthPersonGetsNthSeat(self, n):
        return 0.5
",,,,,,,,,,"Wrong Answer

99 / 100 testcases passed
Input
n =
1
Use Testcase

Output
0.50000
Expected
1.00000


"
32,Medium,419,"class Solution(object):
    def countBattleships(self, board):
        count = 0
        for i in range(len(board)):
            for j in range(len(board[0])):
                if board[i][j] == 'X':
                    # Check if it's the start of a battleship
                    if i > 0 and board[i-1][j] == 'X':
                        continue
                    if j > 0 and board[i][j-1] == 'X':
                        continue
                    count += 1
        return count
",,,,,,,,,,,,"97.62, 47.62","class Solution(object):
    def countBattleships(self, board):
        count = 0
        for i in range(len(board)):
            for j in range(len(board[0])):
                if board[i][j] == 'X' and (i == 0 or board[i-1][j] == '.') and (j == 0 or board[i][j-1] == '.'):
                    count += 1
        return count
","35.71, 71.43","class Solution(object):
    def countBattleships(self, board):
        count = 0
        for i in range(len(board)):
            for j in range(len(board[0])):
                if board[i][j] == 'X' and (i == 0 or board[i-1][j] == '.') and (j == 0 or board[i][j-1] == '.'):
                    count += 1
                    board[i][j] = '.'  # Mark the battleship as visited
        return count
",,,,,,,,"Wrong Answer

10 / 27 testcases passed
Input
board =
[[""X"",""."",""."",""X""],[""."",""."",""."",""X""],[""."",""."",""."",""X""]]
Use Testcase

Output
4
Expected
2


"
33,Medium,1352,"class ProductOfNumbers(object):
    def __init__(self):
        self.prefix_products = [1]

    def add(self, num):
        """"""
        :type num: int
        :rtype: None
        """"""
        if num == 0:
            self.prefix_products = [1]
        else:
            self.prefix_products.append(self.prefix_products[-1] * num)

    def getProduct(self, k):
        """"""
        :type k: int
        :rtype: int
        """"""
        if k >= len(self.prefix_products):
            return 0
        return self.prefix_products[-1] // self.prefix_products[-k-1]
",,,,,,,,,,,,"37.5, 92.19","class ProductOfNumbers(object):
    def __init__(self):
        self.prefix_products = [1]
        self.last_zero_index = -1

    def add(self, num):
        """"""
        :type num: int
        :rtype: None
        """"""
        if num == 0:
            self.prefix_products = [1]
            self.last_zero_index = len(self.prefix_products) - 1
        else:
            if self.last_zero_index >= 0:
                self.prefix_products.append(self.prefix_products[self.last_zero_index] * num)
            else:
                self.prefix_products.append(self.prefix_products[-1] * num)

    def getProduct(self, k):
        """"""
        :type k: int
        :rtype: int
        """"""
        if k >= len(self.prefix_products):
            return 0
        return self.prefix_products[-1] // self.prefix_products[-k-1]
",,,,,,,,,,"Wrong Answer

26 / 33 testcases passed
Input
[""ProductOfNumbers"",""add"",""add"",""add"",""add"",""add"",""getProduct"",""getProduct"",""getProduct"",""add"",""getProduct""]
[[],[3],[0],[2],[5],[4],[2],[3],[4],[8],[2]]
Use Testcase

Output
[null,null,null,null,null,null,2,4,0,null,1]
Expected
[null,null,null,null,null,null,20,40,0,null,32]


"
34,Medium,1653,"class Solution(object):
    def minimumDeletions(self, s):
        """"""
        :type s: str
        :rtype: int
        """"""
        count_b = 0  # Count of 'b' characters encountered
        deletions = 0  # Minimum number of deletions needed

        for char in s:
            if char == 'a':
                # If 'a' is encountered, we need to check if there are any preceding 'b' characters
                # If yes, we can delete the 'a' to balance the string
                deletions = min(deletions + 1, count_b)
            else:
                # If 'b' is encountered, increment the count of 'b' characters
                count_b += 1

        return deletions
",,,,,,,,,,,,"66.67, 80","class Solution(object):
    def minimumDeletions(self, s):
        """"""
        :type s: str
        :rtype: int
        """"""
        deletions = 0  # Minimum number of deletions needed
        count_b = 0  # Count of 'b' characters encountered

        for char in s:
            if char == 'a':
                # If 'a' is encountered, we need to check if there are any preceding 'b' characters
                # If yes, we can delete the 'a' to balance the string
                deletions = min(deletions + 1, count_b)
            else:
                # If 'b' is encountered, increment the count of 'b' characters
                count_b += 1

        return deletions
","66.67, 93.33",X,,,,,,,,
35,Medium,2507,"import math

class Solution(object):
    def smallestValue(self, n):
        num = n
        factors = []
        
        while not self.isPrime(num):
            for i in range(2, int(math.sqrt(num)) + 1):
                if num % i == 0:
                    factors.append(i)
                    while num % i == 0:
                        num //= i
        
        if num > 1:
            factors.append(num)
        
        return sum(factors)
    
    def isPrime(self, num):
        if num < 2:
            return False
        for i in range(2, int(math.sqrt(num)) + 1):
            if num % i == 0:
                return False
        return True
","Wrong Answer

2 / 209 testcases passed
Input
n =
15
Use Testcase

Output
8
Expected
5


","import math

class Solution(object):
    def smallestValue(self, n):
        num = n
        factors = []
        
        while not self.isPrime(num):
            found_factor = False
            for i in range(2, int(math.sqrt(num)) + 1):
                if num % i == 0:
                    factors.append(i)
                    num //= i
                    found_factor = True
                    break
            
            if not found_factor:
                # num is a prime factor
                factors.append(num)
                break
        
        return sum(factors)
    
    def isPrime(self, num):
        if num < 2:
            return False
        for i in range(2, int(math.sqrt(num)) + 1):
            if num % i == 0:
                return False
        return True
","Wrong Answer

14 / 209 testcases passed
Input
n =
15
Use Testcase

Output
3
Expected
5


","import math

class Solution(object):
    def smallestValue(self, n):
        num = n
        factors = []
        
        while not self.isPrime(num):
            found_factor = False
            for i in range(2, int(math.sqrt(num)) + 1):
                if num % i == 0:
                    factors.append(i)
                    num //= i
                    found_factor = True
                    break
            
            if not found_factor:
                # num is a prime factor
                factors.append(num)
                break
        
        factors.append(num)  # Add the final prime factor
        
        return sum(factors)
    
    def isPrime(self, num):
        if num < 2:
            return False
        for i in range(2, int(math.sqrt(num)) + 1):
            if num % i == 0:
                return False
        return True
","Wrong Answer

76 / 209 testcases passed
Input
n =
15
Use Testcase

Output
8
Expected
5


","import math

class Solution(object):
    def smallestValue(self, n):
        num = n
        while not self.isPrime(num):
            prime_factors = self.getPrimeFactors(num)
            num = sum(prime_factors)
        return num
    
    def isPrime(self, num):
        if num < 2:
            return False
        for i in range(2, int(math.sqrt(num)) + 1):
            if num % i == 0:
                return False
        return True
    
    def getPrimeFactors(self, num):
        factors = []
        while num % 2 == 0:
            factors.append(2)
            num //= 2
        for i in range(3, int(math.sqrt(num)) + 1, 2):
            while num % i == 0:
                factors.append(i)
                num //= i
        if num > 2:
            factors.append(num)
        return factors
","Time Limit Exceeded
3 / 209 testcases passed
Last Executed Input
Use Testcase


n =
4

","import math

class Solution(object):
    def smallestValue(self, n):
        while not self.isPrime(n):
            smallest_factor = self.getSmallestPrimeFactor(n)
            n //= smallest_factor
            n += smallest_factor
        return n
    
    def isPrime(self, num):
        if num < 2:
            return False
        for i in range(2, int(math.sqrt(num)) + 1):
            if num % i == 0:
                return False
        return True
    
    def getSmallestPrimeFactor(self, num):
        if num % 2 == 0:
            return 2
        for i in range(3, int(math.sqrt(num)) + 1, 2):
            if num % i == 0:
                return i
        return num
","Time Limit Exceeded
3 / 209 testcases passed
Last Executed Input
Use Testcase


n =
4

","import math

class Solution(object):
    def smallestValue(self, n):
        smallest_factor = [0] * (n + 1)
        primes = []
        
        for i in range(2, n + 1):
            if smallest_factor[i] == 0:
                primes.append(i)
                smallest_factor[i] = i
            
            j = 0
            while j < len(primes) and primes[j] <= smallest_factor[i] and i * primes[j] <= n:
                smallest_factor[i * primes[j]] = primes[j]
                j += 1
        
        while not self.isPrime(n):
            prime = smallest_factor[n]
            n //= prime
            n += prime
        
        return n
    
    def isPrime(self, num):
        if num < 2:
            return False
        for i in range(2, int(math.sqrt(num)) + 1):
            if num % i == 0:
                return False
        return True
","Time Limit Exceeded
3 / 209 testcases passed
Last Executed Input
Use Testcase


n =
4

",,,,,,,,,,,,
36,Medium,1296,"class Solution(object):
    def isPossibleDivide(self, nums, k):
        if len(nums) % k != 0:
            return False
        
        num_count = {}
        for num in nums:
            num_count[num] = num_count.get(num, 0) + 1
        
        sorted_nums = sorted(num_count.keys())
        
        for num in sorted_nums:
            if num_count[num] > 0:
                count = num_count[num]
                for i in range(num, num + k):
                    if num_count.get(i, 0) < count:
                        return False
                    num_count[i] -= count
        
        return True
",,,,,,,,,,,,"84, 80","from collections import Counter
import heapq

class Solution(object):
    def isPossibleDivide(self, nums, k):
        if len(nums) % k != 0:
            return False
        
        num_count = Counter(nums)
        min_heap = []
        
        for num in num_count:
            heapq.heappush(min_heap, num)
        
        while min_heap:
            curr = heapq.heappop(min_heap)
            
            if num_count[curr] == 0:
                continue
            
            count = num_count[curr]
            
            for i in range(curr, curr + k):
                if num_count[i] < count:
                    return False
                num_count[i] -= count
        
        return True
","28, 64","from collections import Counter

class Solution(object):
    def isPossibleDivide(self, nums, k):
        if len(nums) % k != 0:
            return False
        
        num_count = Counter(nums)
        
        while num_count:
            min_num = min(num_count.keys())
            count = num_count[min_num]
            
            for num in range(min_num, min_num + k):
                if num_count[num] < count:
                    return False
                num_count[num] -= count
                if num_count[num] == 0:
                    del num_count[num]
        
        return True
","68, 28","class Solution(object):
    def isPossibleDivide(self, nums, k):
        if len(nums) % k != 0:
            return False
        
        max_num = max(nums)
        counts = [0] * (max_num + 1)
        
        for num in nums:
            counts[num] += 1
        
        for i in range(len(counts)):
            while counts[i] > 0:
                for j in range(i, i + k):
                    if counts[j] == 0:
                        return False
                    counts[j] -= 1
        
        return True
",,,,,,"Runtime Error
19 / 60 testcases passed
IndexError: list index out of range
    if counts[j] == 0:
Line 15 in isPossibleDivide (Solution.py)
    ret = Solution().isPossibleDivide(param_1, param_2)
Line 44 in _driver (Solution.py)
    _driver()
Line 54 in <module> (Solution.py)


"
37,Medium,1765,"class Solution(object):
    def highestPeak(self, isWater):
        """"""
        :type isWater: List[List[int]]
        :rtype: List[List[int]]
        """"""
        m, n = len(isWater), len(isWater[0])
        height = [[-1] * n for _ in range(m)]  # Initialize the height matrix

        queue = []  # Queue for BFS traversal

        # Initialize the water cells with height 0 and add them to the queue
        for i in range(m):
            for j in range(n):
                if isWater[i][j] == 1:
                    height[i][j] = 0
                    queue.append((i, j))

        # Perform BFS traversal starting from the water cells
        while queue:
            x, y = queue.pop(0)

            # Check adjacent cells (up, down, left, right)
            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                nx, ny = x + dx, y + dy

                # Check if the adjacent cell is within the grid and not visited
                if 0 <= nx < m and 0 <= ny < n and height[nx][ny] == -1:
                    height[nx][ny] = height[x][y] + 1
                    queue.append((nx, ny))

        return height
",,,,,,,,,,,,"6.67, 86.67","from collections import deque

class Solution(object):
    def highestPeak(self, isWater):
        """"""
        :type isWater: List[List[int]]
        :rtype: List[List[int]]
        """"""
        m, n = len(isWater), len(isWater[0])
        height = [[-1] * n for _ in range(m)]  # Initialize the height matrix

        queue = deque()  # Queue for bidirectional BFS traversal

        # Initialize the water cells with height 0 and add them to the queue
        for i in range(m):
            for j in range(n):
                if isWater[i][j] == 1:
                    height[i][j] = 0
                    queue.append((i, j, 1))  # Mark water cells with source = 1

        # Perform bidirectional BFS traversal starting from the water cells and land cells simultaneously
        while queue:
            x, y, source = queue.popleft()

            # Check adjacent cells (up, down, left, right)
            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                nx, ny = x + dx, y + dy

                # Check if the adjacent cell is within the grid and not visited
                if 0 <= nx < m and 0 <= ny < n and height[nx][ny] == -1:
                    height[nx][ny] = height[x][y] + 1
                    queue.append((nx, ny, source))

        return height
","80, 80","import heapq

class Solution(object):
    def highestPeak(self, isWater):
        """"""
        :type isWater: List[List[int]]
        :rtype: List[List[int]]
        """"""
        m, n = len(isWater), len(isWater[0])
        height = [[-1] * n for _ in range(m)]  # Initialize the height matrix

        # Initialize the priority queue with water cells
        pq = []
        for i in range(m):
            for j in range(n):
                if isWater[i][j] == 1:
                    height[i][j] = 0
                    heapq.heappush(pq, (0, i, j))  # Priority queue based on height

        # Perform Dijkstra's algorithm
        while pq:
            h, x, y = heapq.heappop(pq)

            # Check adjacent cells (up, down, left, right)
            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                nx, ny = x + dx, y + dy

                # Check if the adjacent cell is within the grid and not visited
                if 0 <= nx < m and 0 <= ny < n and height[nx][ny] == -1:
                    height[nx][ny] = h + 1
                    heapq.heappush(pq, (h + 1, nx, ny))  # Add the adjacent cell to the priority queue

        return height
","66.67, 73.33","class Solution(object):
    def highestPeak(self, isWater):
        """"""
        :type isWater: List[List[int]]
        :rtype: List[List[int]]
        """"""
        m, n = len(isWater), len(isWater[0])
        height = [[-1] * n for _ in range(m)]  # Initialize the height matrix

        queue = []  # Queue for flood fill

        # Initialize the water cells with height 0 and add them to the queue
        for i in range(m):
            for j in range(n):
                if isWater[i][j] == 1:
                    height[i][j] = 0
                    queue.append((i, j))

        # Perform flood fill
        while queue:
            x, y = queue.pop(0)

            # Check adjacent cells (up, down, left, right)
            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                nx, ny = x + dx, y + dy

                # Check if the adjacent cell is within the grid and not visited
                if 0 <= nx < m and 0 <= ny < n and height[nx][ny] == -1:
                    height[nx][ny] = height[x][y] + 1
                    queue.append((nx, ny))

        return height
","6.67, 86.67","from collections import deque

class Solution(object):
    def highestPeak(self, isWater):
        """"""
        :type isWater: List[List[int]]
        :rtype: List[List[int]]
        """"""
        m, n = len(isWater), len(isWater[0])
        height = [[-1] * n for _ in range(m)]  # Initialize the height matrix

        queue = deque()  # Queue for flood fill

        # Initialize the water cells with height 0 and add them to the queue
        for i in range(m):
            for j in range(n):
                if isWater[i][j] == 1:
                    height[i][j] = 0
                    queue.append((i, j))

        # Perform flood fill
        while queue:
            x, y = queue.popleft()

            # Check adjacent cells (up, down, left, right)
            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                nx, ny = x + dx, y + dy

                # Check if the adjacent cell is within the grid and not visited
                if 0 <= nx < m and 0 <= ny < n and height[nx][ny] == -1:
                    height[nx][ny] = height[x][y] + 1
                    queue.append((nx, ny))

        return height
","86.67, 73.33",X,,
38,Medium,764,"class Solution(object):
    def orderOfLargestPlusSign(self, n, mines):
        # Create a grid filled with 1s
        grid = [[1] * n for _ in range(n)]
        
        # Mark the mines as 0 in the grid
        for mine in mines:
            row, col = mine
            grid[row][col] = 0
        
        # Initialize the dp arrays
        left = [[0] * n for _ in range(n)]
        right = [[0] * n for _ in range(n)]
        up = [[0] * n for _ in range(n)]
        down = [[0] * n for _ in range(n)]
        
        # Pre-compute the left and up dp arrays
        for i in range(n):
            for j in range(n):
                if grid[i][j] == 1:
                    left[i][j] = 1 if j == 0 else left[i][j-1] + 1
                    up[i][j] = 1 if i == 0 else up[i-1][j] + 1
        
        # Pre-compute the right and down dp arrays
        for i in range(n-1, -1, -1):
            for j in range(n-1, -1, -1):
                if grid[i][j] == 1:
                    right[i][j] = 1 if j == n-1 else right[i][j+1] + 1
                    down[i][j] = 1 if i == n-1 else down[i+1][j] + 1
        
        # Find the order of the largest plus sign
        order = 0
        for i in range(n):
            for j in range(n):
                if grid[i][j] == 1:
                    length = min(left[i][j], right[i][j], up[i][j], down[i][j])
                    order = max(order, length)
        
        return order
",,,,,,,,,,,,"100, 66.67","class Solution(object):
    def orderOfLargestPlusSign(self, n, mines):
        # Create a set of mine positions for quick lookup
        mines_set = set((x, y) for x, y in mines)
        
        # Initialize the dp arrays
        dp = [[0] * n for _ in range(n)]
        
        # Compute the dp arrays
        order = 0
        for i in range(n):
            left, right, up, down = 0, 0, 0, 0
            for j in range(n):
                left = 0 if (i, j) in mines_set else left + 1
                dp[i][j] = min(dp[i][j], left)
                
                right = 0 if (i, n - 1 - j) in mines_set else right + 1
                dp[i][n - 1 - j] = min(dp[i][n - 1 - j], right)
                
                up = 0 if (j, i) in mines_set else up + 1
                dp[j][i] = min(dp[j][i], up)
                
                down = 0 if (n - 1 - j, i) in mines_set else down + 1
                dp[n - 1 - j][i] = min(dp[n - 1 - j][i], down)
                
                order = max(order, dp[i][j])
        
        return order
",,,,,,,,,,"Wrong Answer

3 / 56 testcases passed
Input
n =
5
mines =
[[4,2]]
Use Testcase

Output
0
Expected
2


"
39,Medium,368,"class Solution(object):
    def largestDivisibleSubset(self, nums):
        """"""
        :type nums: List[int]
        :rtype: List[int]
        """"""
        if not nums:
            return []

        # Sort the numbers in ascending order
        nums.sort()

        # Initialize variables to store the maximum subset and its length
        max_subset = []
        max_length = 0

        # Initialize two lists: dp to track the length of subsets and prev to track the previous element in the subset
        dp = [1] * len(nums)
        prev = [-1] * len(nums)

        # Iterate through the numbers
        for i in range(len(nums)):
            # Iterate from the beginning of the list up to the current number
            for j in range(i):
                # If nums[i] is divisible by nums[j], it can be part of a larger subset
                if nums[i] % nums[j] == 0:
                    # Update the length of the subset and the previous element
                    if dp[j] + 1 > dp[i]:
                        dp[i] = dp[j] + 1
                        prev[i] = j

            # Check if the current subset is the largest
            if dp[i] > max_length:
                max_length = dp[i]
                max_subset = []

                # Reconstruct the subset using the previous elements
                k = i
                while k != -1:
                    max_subset.append(nums[k])
                    k = prev[k]

        # Return the largest subset
        return max_subset[::-1]
",,,,,,,,,,,,"43.4, 84.91","class Solution(object):
    def largestDivisibleSubset(self, nums):
        """"""
        :type nums: List[int]
        :rtype: List[int]
        """"""
        if not nums:
            return []

        # Sort the numbers in ascending order
        nums.sort()

        # Initialize variables to store the maximum subset and its length
        max_subset = []
        max_length = 0

        # Initialize a list to track the length of subsets
        dp = [1] * len(nums)

        # Initialize a list to track the previous element in the subset
        prev = [-1] * len(nums)

        # Iterate through the numbers
        for i in range(len(nums)):
            # Iterate from the beginning of the list up to the current number
            for j in range(i):
                # If nums[i] is divisible by nums[j], it can be part of a larger subset
                if nums[i] % nums[j] == 0:
                    # Update the length of the subset and the previous element
                    if dp[j] + 1 > dp[i]:
                        dp[i] = dp[j] + 1
                        prev[i] = j

            # Check if the current subset is the largest
            if dp[i] > max_length:
                max_length = dp[i]
                max_subset = [nums[i]]

        # Reconstruct the largest subset using the previous elements
        while max_subset and prev[nums.index(max_subset[-1])] != -1:
            max_subset.append(nums[prev[nums.index(max_subset[-1])]])
        
        # Return the largest subset in reverse order
        return max_subset[::-1]
","47.17, 56.60",X,,,,,,,,
40,Medium,1514,"import heapq

class Solution(object):
    def maxProbability(self, n, edges, succProb, start, end):
        """"""
        :type n: int
        :type edges: List[List[int]]
        :type succProb: List[float]
        :type start: int
        :type end: int
        :rtype: float
        """"""
        # Build the adjacency list representation of the graph
        graph = [[] for _ in range(n)]
        for i, (a, b) in enumerate(edges):
            p = succProb[i]
            graph[a].append((b, p))
            graph[b].append((a, p))

        # Initialize distances with negative logarithm of success probabilities
        distances = [-float('inf')] * n
        distances[start] = 0.0

        # Priority queue for Dijkstra's algorithm
        pq = []
        heapq.heappush(pq, (-distances[start], start))

        # Dijkstra's algorithm
        while pq:
            dist, node = heapq.heappop(pq)
            dist = -dist  # Retrieve the distance value

            # Skip if the node has been visited before with a shorter distance
            if dist > distances[node]:
                continue

            # Explore the neighbors of the current node
            for neighbor, prob in graph[node]:
                new_dist = dist + math.log(prob)  # Calculate the new distance
                if new_dist > distances[neighbor]:
                    distances[neighbor] = new_dist
                    heapq.heappush(pq, (-new_dist, neighbor))

        # Return the success probability at the end node
        return math.exp(distances[end])
",,,,,,,,,,,,"51.67, 81.67","import heapq

class Solution(object):
    def maxProbability(self, n, edges, succProb, start, end):
        """"""
        :type n: int
        :type edges: List[List[int]]
        :type succProb: List[float]
        :type start: int
        :type end: int
        :rtype: float
        """"""
        # Build the adjacency list representation of the graph
        graph = [[] for _ in range(n)]
        for i, (a, b) in enumerate(edges):
            p = succProb[i]
            graph[a].append((b, p))
            graph[b].append((a, p))

        # Initialize distances with negative logarithm of success probabilities
        distances = [-float('inf')] * n
        distances[start] = 0.0

        # Min-heap for Dijkstra's algorithm
        heap = [(-distances[start], start)]

        # Dijkstra's algorithm
        while heap:
            dist, node = heapq.heappop(heap)
            dist = -dist  # Retrieve the distance value

            # Skip if the node has been visited before with a shorter distance
            if dist > distances[node]:
                continue

            # Explore the neighbors of the current node
            for neighbor, prob in graph[node]:
                new_dist = dist + math.log(prob)  # Calculate the new distance
                if new_dist > distances[neighbor]:
                    distances[neighbor] = new_dist
                    heapq.heappush(heap, (-new_dist, neighbor))

        # Return the success probability at the end node
        return math.exp(distances[end])
","51.67, 85","from heapdict import heapdict

class Solution(object):
    def maxProbability(self, n, edges, succProb, start, end):
        """"""
        :type n: int
        :type edges: List[List[int]]
        :type succProb: List[float]
        :type start: int
        :type end: int
        :rtype: float
        """"""
        # Build the adjacency list representation of the graph
        graph = [[] for _ in range(n)]
        for i, (a, b) in enumerate(edges):
            p = succProb[i]
            graph[a].append((b, p))
            graph[b].append((a, p))

        # Initialize distances with negative logarithm of success probabilities
        distances = [-float('inf')] * n
        distances[start] = 0.0

        # Priority queue for Dijkstra's algorithm with key updates
        pq = heapdict()
        pq[start] = 0.0

        # Dijkstra's algorithm
        while pq:
            node, dist = pq.popitem()
            dist = -dist  # Retrieve the distance value

            # Skip if the node has been visited before with a shorter distance
            if dist > distances[node]:
                continue

            # Explore the neighbors of the current node
            for neighbor, prob in graph[node]:
                new_dist = dist + math.log(prob)  # Calculate the new distance
                if new_dist > distances[neighbor]:
                    distances[neighbor] = new_dist
                    pq[neighbor] = -new_dist

        # Return the success probability at the end node
        return math.exp(distances[end])
",,,,,,,,"Runtime Error
0 / 18 testcases passed
ImportError: No module named heapdict
    from heapdict import heapdict
Line 1 in <module> (Solution.py)
Last Executed Input
Use Testcase

n =
3
edges =
[[0,1],[1,2],[0,2]]
succProb =
[0.5,0.5,0.2]
start =
0

end =
2

"
41,Hard,913,"from collections import deque

class Solution(object):
    def catMouseGame(self, graph):
        n = len(graph)
        dp = [[[-1] * 2 for _ in range(n)] for _ in range(n)]
        queue = deque()

        for i in range(n):
            for j in range(n):
                dp[0][i][1] = 2
                dp[i][i][1] = 2
                dp[i][i][0] = 1
                queue.append((0, i, 1))
                queue.append((i, i, 1))
                queue.append((i, i, 0))

        while queue:
            mouse, cat, turn = queue.popleft()

            for prev_mouse in graph[mouse]:
                if prev_mouse == 0:
                    continue

                for prev_cat in graph[cat]:
                    if prev_cat == 0 and turn == 1:
                        continue

                    if dp[prev_mouse][prev_cat][1 - turn] != -1:
                        continue

                    if turn == 0:
                        dp[prev_mouse][prev_cat][1 - turn] = 1
                    else:
                        is_cat_winning = True
                        for next_mouse in graph[prev_mouse]:
                            if dp[next_mouse][prev_cat][1 - turn] != 2:
                                is_cat_winning = False
                                break

                        if is_cat_winning:
                            dp[prev_mouse][prev_cat][1 - turn] = 2
                        else:
                            dp[prev_mouse][prev_cat][1 - turn] = 0

                    queue.append((prev_mouse, prev_cat, 1 - turn))

        return dp[1][2][0]
","Wrong Answer

6 / 92 testcases passed
Input
graph =
[[1,3],[0],[3],[0,2]]
Use Testcase

Output
0
Expected
1


","from collections import deque

class Solution(object):
    def catMouseGame(self, graph):
        n = len(graph)
        dp = [[[None] * 2 for _ in range(n)] for _ in range(n)]
        queue = deque()

        for i in range(n):
            for j in range(n):
                dp[i][j][0] = 0  # Draw
                dp[i][j][1] = 0  # Draw

                if i == 0:
                    dp[i][j][0] = 1  # Mouse wins if mouse reaches the hole
                    dp[i][j][1] = 1  # Mouse wins if mouse reaches the hole
                    queue.append((i, j, 0))
                    queue.append((i, j, 1))

        while queue:
            mouse, cat, turn = queue.popleft()

            for prev_mouse in graph[mouse]:
                if prev_mouse == 0:
                    continue  # Skip if the mouse goes to the hole

                for prev_cat in graph[cat]:
                    if prev_cat == 0 and turn == 1:
                        continue  # Skip if the cat goes to the hole

                    if dp[prev_mouse][prev_cat][turn] != 0:
                        continue  # Skip if the state is already determined

                    if turn == 0:
                        dp[prev_mouse][prev_cat][turn] = 1  # Mouse's turn, mouse can win

                        # Enqueue all the previous states
                        for next_cat in graph[prev_cat]:
                            queue.append((prev_mouse, next_cat, 1))
                    else:
                        # Cat's turn, cat can win only if all next states are winning for the cat
                        is_cat_winning = True
                        for next_mouse in graph[prev_mouse]:
                            if dp[next_mouse][prev_cat][turn] != 1:
                                is_cat_winning = False
                                break

                        if is_cat_winning:
                            dp[prev_mouse][prev_cat][turn] = 2  # Cat wins

                            # Enqueue all the previous states
                            for next_mouse in graph[prev_mouse]:
                                queue.append((next_mouse, prev_cat, 0))
                    if dp[prev_mouse][prev_cat][turn] != 0:
                        queue.append((prev_mouse, prev_cat, turn))

        return dp[1][2][0]
","Wrong Answer

36 / 92 testcases passed
Input
graph =
[[2,5],[3],[0,4,5],[1,4,5],[2,3],[0,2,3]]
Use Testcase

Output
1
Expected
0


","from collections import deque

class Solution(object):
    def catMouseGame(self, graph):
        n = len(graph)
        DRAW, MOUSE, CAT = 0, 1, 2
        dp = [[[None] * 3 for _ in range(n)] for _ in range(n)]
        queue = deque()

        for i in range(n):
            for j in range(n):
                if i == 0:
                    dp[i][j][MOUSE] = MOUSE  # Mouse wins if mouse reaches the hole
                    dp[i][j][CAT] = MOUSE  # Mouse wins if mouse reaches the hole
                    queue.append((i, j, MOUSE))
                    if j > 0:
                        dp[i][j][CAT] = CAT  # Cat wins if the cat reaches the mouse
                        queue.append((i, j, CAT))
                elif i == j:
                    dp[i][j][MOUSE] = CAT  # Cat wins if the mouse and cat are at the same position
                    dp[i][j][CAT] = CAT  # Cat wins if the mouse and cat are at the same position
                    queue.append((i, j, MOUSE))
                    queue.append((i, j, CAT))

        while queue:
            mouse, cat, turn = queue.popleft()

            for prev_mouse in graph[mouse]:
                for prev_cat in graph[cat]:
                    if prev_mouse == 0:
                        continue  # Skip if the mouse goes to the hole
                    if prev_mouse == prev_cat:
                        continue  # Skip if the mouse and cat are at the same position
                    if dp[prev_mouse][prev_cat][turn] is not None:
                        continue  # Skip if the state is already determined

                    if turn == MOUSE:
                        dp[prev_mouse][prev_cat][turn] = MOUSE  # Mouse wins

                        # Enqueue all the previous states with the same turn
                        for next_mouse in graph[prev_mouse]:
                            if next_mouse != 0:
                                queue.append((next_mouse, prev_cat, turn))
                    else:
                        is_cat_winning = True
                        for next_cat in graph[prev_cat]:
                            if next_cat != 0 and dp[prev_mouse][next_cat][turn] != MOUSE:
                                is_cat_winning = False
                                break

                        if is_cat_winning:
                            dp[prev_mouse][prev_cat][turn] = CAT  # Cat wins

                            # Enqueue all the previous states with the opposite turn
                            for next_cat in graph[prev_cat]:
                                queue.append((prev_mouse, next_cat, MOUSE))
                    if dp[prev_mouse][prev_cat][turn] is not None:
                        queue.append((prev_mouse, prev_cat, turn))

        return dp[1][2][MOUSE]
","Wrong Answer

39 / 92 testcases passed
Input
graph =
[[2,5],[3],[0,4,5],[1,4,5],[2,3],[0,2,3]]
Use Testcase

Output
1
Expected
0


","from collections import deque

class Solution(object):
    def catMouseGame(self, graph):
        n = len(graph)
        DRAW, MOUSE, CAT = 0, 1, 2
        dp = [[[None] * 3 for _ in range(n)] for _ in range(n)]
        queue = deque()

        for i in range(n):
            for j in range(n):
                if i == 0:
                    dp[i][j][MOUSE] = MOUSE  # Mouse wins if mouse reaches the hole
                    dp[i][j][CAT] = MOUSE  # Mouse wins if mouse reaches the hole
                    queue.append((i, j, MOUSE))
                    if j > 0:
                        dp[i][j][CAT] = CAT  # Cat wins if the cat reaches the mouse
                        queue.append((i, j, CAT))
                elif i == j:
                    dp[i][j][MOUSE] = CAT  # Cat wins if the mouse and cat are at the same position
                    dp[i][j][CAT] = CAT  # Cat wins if the mouse and cat are at the same position
                    queue.append((i, j, MOUSE))
                    queue.append((i, j, CAT))

        while queue:
            mouse, cat, turn = queue.popleft()

            for prev_mouse in graph[mouse]:
                for prev_cat in graph[cat]:
                    if prev_mouse == 0:
                        continue  # Skip if the mouse goes to the hole
                    if prev_mouse == prev_cat:
                        continue  # Skip if the mouse and cat are at the same position
                    if dp[prev_mouse][prev_cat][turn] is not None:
                        continue  # Skip if the state is already determined

                    if turn == MOUSE:
                        dp[prev_mouse][prev_cat][turn] = MOUSE  # Mouse wins

                        # Enqueue all the previous states with the same turn
                        for next_cat in graph[prev_cat]:
                            if next_cat != 0:
                                queue.append((prev_mouse, next_cat, CAT))
                    else:
                        is_cat_winning = True
                        for next_mouse in graph[prev_mouse]:
                            if dp[next_mouse][prev_cat][turn] != MOUSE:
                                is_cat_winning = False
                                break

                        if is_cat_winning:
                            dp[prev_mouse][prev_cat][turn] = CAT  # Cat wins

                            # Enqueue all the previous states with the opposite turn
                            for next_mouse in graph[prev_mouse]:
                                queue.append((next_mouse, prev_cat, MOUSE))
                    if dp[prev_mouse][prev_cat][turn] is not None:
                        queue.append((prev_mouse, prev_cat, turn))

        return dp[1][2][MOUSE]
","Wrong Answer

36 / 92 testcases passed
Input
graph =
[[2,5],[3],[0,4,5],[1,4,5],[2,3],[0,2,3]]
Use Testcase

Output
1
Expected
0
","from collections import deque

class Solution(object):
    def catMouseGame(self, graph):
        n = len(graph)
        DRAW, MOUSE, CAT = 0, 1, 2
        dp = [[[None] * 3 for _ in range(n)] for _ in range(n)]
        queue = deque()

        for i in range(n):
            for j in range(n):
                if i == 0:
                    dp[i][j][MOUSE] = MOUSE  # Mouse wins if mouse reaches the hole
                    dp[i][j][CAT] = MOUSE  # Mouse wins if mouse reaches the hole
                    queue.append((i, j, MOUSE))
                    if j > 0:
                        dp[i][j][CAT] = CAT  # Cat wins if the cat reaches the mouse
                        queue.append((i, j, CAT))
                elif i == j:
                    dp[i][j][MOUSE] = CAT  # Cat wins if the mouse and cat are at the same position
                    dp[i][j][CAT] = CAT  # Cat wins if the mouse and cat are at the same position
                    queue.append((i, j, MOUSE))
                    queue.append((i, j, CAT))

        while queue:
            mouse, cat, turn = queue.popleft()

            for prev_mouse in graph[mouse]:
                if prev_mouse == 0:
                    continue  # Skip if the mouse goes to the hole

                for prev_cat in graph[cat]:
                    if prev_cat == 0 and turn == CAT:
                        continue  # Skip if the cat goes to the hole

                    if dp[prev_mouse][prev_cat][turn] is not None:
                        continue  # Skip if the state is already determined

                    if turn == MOUSE:
                        dp[prev_mouse][prev_cat][turn] = MOUSE  # Mouse wins

                        # Enqueue all the previous states with the same turn
                        for next_cat in graph[prev_cat]:
                            if next_cat != 0:
                                queue.append((prev_mouse, next_cat, CAT))
                    else:
                        is_cat_winning = True
                        for next_mouse in graph[prev_mouse]:
                            if dp[next_mouse][prev_cat][turn] != MOUSE:
                                is_cat_winning = False
                                break

                        if is_cat_winning:
                            dp[prev_mouse][prev_cat][turn] = CAT  # Cat wins

                            # Enqueue all the previous states with the opposite turn
                            for next_mouse in graph[prev_mouse]:
                                if next_mouse != 0:
                                    queue.append((next_mouse, prev_cat, MOUSE))
                    if dp[prev_mouse][prev_cat][turn] is not None:
                        queue.append((prev_mouse, prev_cat, turn))

        return dp[1][2][MOUSE]
","Wrong Answer

37 / 92 testcases passed
Input
graph =
[[2,5],[3],[0,4,5],[1,4,5],[2,3],[0,2,3]]
Use Testcase

Output
1
Expected
0


","from collections import deque

class Solution(object):
    def catMouseGame(self, graph):
        n = len(graph)
        DRAW, MOUSE, CAT = 0, 1, 2
        dp = [[[None] * 3 for _ in range(n)] for _ in range(n)]
        queue = deque()

        for i in range(n):
            for j in range(n):
                if i == 0:
                    dp[i][j][MOUSE] = MOUSE  # Mouse wins if mouse reaches the hole
                    dp[i][j][CAT] = MOUSE  # Mouse wins if mouse reaches the hole
                    queue.append((i, j, MOUSE))
                    if j > 0:
                        dp[i][j][CAT] = CAT  # Cat wins if the cat reaches the mouse
                        queue.append((i, j, CAT))
                elif i == j:
                    dp[i][j][MOUSE] = CAT  # Cat wins if the mouse and cat are at the same position
                    dp[i][j][CAT] = CAT  # Cat wins if the mouse and cat are at the same position
                    queue.append((i, j, MOUSE))
                    queue.append((i, j, CAT))

        while queue:
            mouse, cat, turn = queue.popleft()

            if turn == MOUSE:
                # Mouse's turn, check all previous positions of the cat
                for prev_mouse in graph[mouse]:
                    if prev_mouse == 0:
                        continue  # Skip if the mouse goes to the hole

                    for prev_cat in graph[cat]:
                        if prev_cat == 0:
                            continue  # Skip if the cat goes to the hole

                        if dp[prev_mouse][prev_cat][turn] is not None:
                            continue  # Skip if the state is already determined

                        dp[prev_mouse][prev_cat][turn] = MOUSE  # Mouse wins

                        # Enqueue all the previous states with the same turn
                        for next_mouse in graph[prev_mouse]:
                            queue.append((next_mouse, prev_cat, CAT))

            else:
                # Cat's turn, check all previous positions of the mouse
                for prev_cat in graph[cat]:
                    if prev_cat == 0:
                        continue  # Skip if the cat goes to the hole

                    for prev_mouse in graph[mouse]:
                        if dp[prev_mouse][prev_cat][turn] is not None:
                            continue  # Skip if the state is already determined

                        is_cat_winning = True
                        for next_cat in graph[prev_cat]:
                            if dp[prev_mouse][next_cat][turn] != MOUSE:
                                is_cat_winning = False
                                break

                        if is_cat_winning:
                            dp[prev_mouse][prev_cat][turn] = CAT  # Cat wins

                            # Enqueue all the previous states with the opposite turn
                            for next_cat in graph[prev_cat]:
                                if next_cat != 0:
                                    queue.append((prev_mouse, next_cat, MOUSE))

        return dp[1][2][MOUSE]
","Runtime Error
0 / 92 testcases passed
TypeError: None is not valid value for the expected return type integer
    raise TypeError(str(ret) + "" is not valid value for the expected return type integer"");
Line 95 in _driver (Solution.py)
    _driver()
Line 101 in <module> (Solution.py)

Last Executed Input
Use Testcase

graph =
[[2,5],[3],[0,4,5],[1,4,5],[2,3],[0,2,3]]

",,,,,,,,,,,,
42,Hard,174,"class Solution(object):
    def calculateMinimumHP(self, dungeon):
        """"""
        :type dungeon: List[List[int]]
        :rtype: int
        """"""
        m = len(dungeon)
        n = len(dungeon[0])

        # Create a grid to store the minimum health required
        dp = [[0] * n for _ in range(m)]

        # Fill the grid starting from the bottom-right corner
        for i in range(m - 1, -1, -1):
            for j in range(n - 1, -1, -1):
                if i == m - 1 and j == n - 1:
                    # For the princess's room, the minimum health required is 1
                    dp[i][j] = max(1, 1 - dungeon[i][j])
                elif i == m - 1:
                    # If in the last row, only consider the right cell
                    dp[i][j] = max(dp[i][j + 1] - dungeon[i][j], 1)
                elif j == n - 1:
                    # If in the last column, only consider the bottom cell
                    dp[i][j] = max(dp[i + 1][j] - dungeon[i][j], 1)
                else:
                    # Consider both right and bottom cells, choose the one that requires less health
                    dp[i][j] = max(min(dp[i][j + 1], dp[i + 1][j]) - dungeon[i][j], 1)

        return dp[0][0]
",,,,,,,,,,,,"91.67, 85.71","class Solution(object):
    def calculateMinimumHP(self, dungeon):
        """"""
        :type dungeon: List[List[int]]
        :rtype: int
        """"""
        m = len(dungeon)
        n = len(dungeon[0])

        # Create a one-dimensional array to store the minimum health required for the current row
        dp = [0] * n

        # Fill the array starting from the last column
        dp[n - 1] = max(1, 1 - dungeon[m - 1][n - 1])

        # Calculate the minimum health required for each cell in the grid
        for j in range(n - 2, -1, -1):
            dp[j] = max(dp[j + 1] - dungeon[m - 1][j], 1)

        # Update the array for each row, starting from the second last row
        for i in range(m - 2, -1, -1):
            # Update the last column of the current row
            dp[n - 1] = max(dp[n - 1] - dungeon[i][n - 1], 1)
            
            # Update the rest of the cells in the current row
            for j in range(n - 2, -1, -1):
                dp[j] = max(min(dp[j], dp[j + 1]) - dungeon[i][j], 1)

        return dp[0]
","79.76, 61.9","class Solution(object):
    def calculateMinimumHP(self, dungeon):
        """"""
        :type dungeon: List[List[int]]
        :rtype: int
        """"""
        m = len(dungeon)
        n = len(dungeon[0])

        # Calculate the minimum health required for the princess's room
        dungeon[m - 1][n - 1] = max(1, 1 - dungeon[m - 1][n - 1])

        # Calculate the minimum health required for the last row
        for j in range(n - 2, -1, -1):
            dungeon[m - 1][j] = max(dungeon[m - 1][j + 1] - dungeon[m - 1][j], 1)

        # Calculate the minimum health required for the last column and the rest of the cells
        for i in range(m - 2, -1, -1):
            dungeon[i][n - 1] = max(dungeon[i + 1][n - 1] - dungeon[i][n - 1], 1)
            for j in range(n - 2, -1, -1):
                dungeon[i][j] = max(min(dungeon[i][j + 1], dungeon[i + 1][j]) - dungeon[i][j], 1)

        return dungeon[0][0]
","61.9, 38.1",X,,,,,,
43,Hard,956,"class Solution(object):
    def tallestBillboard(self, rods):
        """"""
        :type rods: List[int]
        :rtype: int
        """"""
        # Create a dictionary to store the maximum achievable height for each sum
        dp = {0: 0}

        # Iterate over each rod
        for rod in rods:
            # Create a copy of the dictionary to avoid modifying it while iterating
            curr_dp = dp.copy()

            # Iterate over each sum in the current dictionary
            for total, height in curr_dp.items():
                # Add the rod to one side of the billboard
                sum_with_rod = total + rod
                dp[sum_with_rod] = max(dp.get(sum_with_rod, 0), height)

                # Add the rod to the other side of the billboard
                diff_with_rod = abs(total - rod)
                dp[diff_with_rod] = max(dp.get(diff_with_rod, 0), height + min(total, rod))

        # Return the maximum height achievable for a sum of 0 (balanced billboard)
        return dp[0]
",,,,,,,,,,,,"60, 40","class Solution(object):
    def tallestBillboard(self, rods):
        """"""
        :type rods: List[int]
        :rtype: int
        """"""
        # Calculate the maximum possible sum
        max_sum = sum(rods)

        # Create a 2D list to store the maximum achievable height for each sum
        # dp[i][j] represents the maximum height achievable with a difference of j for the first i rods
        dp = [[-float('inf')] * (2 * max_sum + 1) for _ in range(len(rods) + 1)]
        dp[0][max_sum] = 0

        # Iterate over each rod
        for i in range(1, len(rods) + 1):
            rod = rods[i - 1]

            # Iterate over each possible difference
            for j in range(-max_sum, max_sum + 1):
                # Skip if the current difference is not achievable
                if dp[i - 1][j + max_sum] == -float('inf'):
                    continue

                # Update the maximum heights for the next rod
                dp[i][j + rod + max_sum] = max(dp[i][j + rod + max_sum], dp[i - 1][j + max_sum] + rod)
                dp[i][j - rod + max_sum] = max(dp[i][j - rod + max_sum], dp[i - 1][j + max_sum])

                # Keep the current rod
                dp[i][j + max_sum] = max(dp[i][j + max_sum], dp[i - 1][j + max_sum])

        # Return the maximum height achievable for a sum of 0 (balanced billboard)
        return dp[len(rods)][max_sum]
","20, 20","class Solution(object):
    def tallestBillboard(self, rods):
        """"""
        :type rods: List[int]
        :rtype: int
        """"""
        # Calculate the maximum possible sum
        max_sum = sum(rods)

        # Create a list to store the maximum achievable height for each sum
        # dp[i] represents the maximum height achievable with a difference of i
        dp = [-float('inf')] * (2 * max_sum + 1)
        dp[max_sum] = 0

        # Iterate over each rod
        for rod in rods:
            curr_dp = dp.copy()

            # Iterate over each possible difference
            for diff in range(-max_sum, max_sum + 1):
                # Skip if the current difference is not achievable
                if dp[diff + max_sum] == -float('inf'):
                    continue

                # Update the maximum heights for the next rod
                dp[diff + rod + max_sum] = max(dp[diff + rod + max_sum], dp[diff + max_sum] + rod)
                dp[diff - rod + max_sum] = max(dp[diff - rod + max_sum], dp[diff + max_sum])

                # Keep the current rod
                dp[diff + max_sum] = max(dp[diff + max_sum], dp[diff + max_sum])

        # Return the maximum height achievable for a sum of 0 (balanced billboard)
        return dp[max_sum]
",,,,,,,,"Runtime Error
0 / 80 testcases passed
AttributeError: 'list' object has no attribute 'copy'
    curr_dp = dp.copy()
Line 17 in tallestBillboard (Solution.py)
    ret = Solution().tallestBillboard(param_1)
Line 53 in _driver (Solution.py)
    _driver()
Line 63 in <module> (Solution.py)
Last Executed Input
Use Testcase


rods =
[1,2,3,6]

"
44,Hard,302,"class Solution(object):
    def minArea(self, image, x, y):
        """"""
        :type image: List[List[str]]
        :type x: int
        :type y: int
        :rtype: int
        """"""
        m, n = len(image), len(image[0])
        left = self.searchColumns(image, 0, y, 0, m, True)
        right = self.searchColumns(image, y + 1, n, 0, m, False)
        top = self.searchRows(image, 0, x, 0, n, True)
        bottom = self.searchRows(image, x + 1, m, 0, n, False)
        return (right - left) * (bottom - top)
    
    def searchColumns(self, image, start, end, top, bottom, isLeft):
        while start < end:
            mid = start + (end - start) // 2
            if self.hasBlackPixel(image, mid, top, bottom, isLeft):
                end = mid
            else:
                start = mid + 1
        return start
    
    def searchRows(self, image, start, end, left, right, isTop):
        while start < end:
            mid = start + (end - start) // 2
            if self.hasBlackPixel(image, mid, left, right, isTop):
                end = mid
            else:
                start = mid + 1
        return start
    
    def hasBlackPixel(self, image, mid, i, j, isRow):
        if isRow:
            while i < j:
                if image[mid][i] == '1':
                    return True
                i += 1
        else:
            while i < j:
                if image[i][mid] == '1':
                    return True
                i += 1
        return False
","Wrong Answer

5 / 111 testcases passed
Input
image =
[[""0"",""0"",""1"",""0""],[""0"",""1"",""1"",""0""],[""0"",""1"",""0"",""0""]]
x =
0
y =
2
Use Testcase

Output
4
Expected
6


","class Solution(object):
    def minArea(self, image, x, y):
        """"""
        :type image: List[List[str]]
        :type x: int
        :type y: int
        :rtype: int
        """"""
        m, n = len(image), len(image[0])
        left = self.searchColumns(image, 0, y, 0, m, True)
        right = self.searchColumns(image, y, n, 0, m, False)
        top = self.searchRows(image, 0, x, 0, n, True)
        bottom = self.searchRows(image, x, m, 0, n, False)
        return (right - left) * (bottom - top)
    
    def searchColumns(self, image, start, end, top, bottom, isLeft):
        while start < end:
            mid = start + (end - start) // 2
            if self.hasBlackPixel(image, mid, top, bottom, isLeft):
                end = mid
            else:
                start = mid + 1
        return start
    
    def searchRows(self, image, start, end, left, right, isTop):
        while start < end:
            mid = start + (end - start) // 2
            if self.hasBlackPixel(image, mid, left, right, isTop):
                end = mid
            else:
                start = mid + 1
        return start
    
    def hasBlackPixel(self, image, mid, i, j, isRow):
        if isRow:
            while i < j:
                if image[mid][i] == '1':
                    return True
                i += 1
        else:
            while i < j:
                if image[i][mid] == '1':
                    return True
                i += 1
        return False
","Runtime Error
0 / 111 testcases passed
IndexError: list index out of range
    if image[i][mid] == '1':
Line 42 in hasBlackPixel (Solution.py)
    if self.hasBlackPixel(image, mid, left, right, isTop):
Line 28 in searchRows (Solution.py)
    bottom = self.searchRows(image, x, m, 0, n, False)
Line 13 in minArea (Solution.py)
    ret = Solution().minArea(param_1, param_2, param_3)
Line 75 in _driver (Solution.py)
    _driver()
Line 85 in <module> (Solution.py)
Last Executed Input
Use Testcase

image =
[[""0"",""0"",""1"",""0""],[""0"",""1"",""1"",""0""],[""0"",""1"",""0"",""0""]]
x =
0

y =
2

","class Solution(object):
    def minArea(self, image, x, y):
        """"""
        :type image: List[List[str]]
        :type x: int
        :type y: int
        :rtype: int
        """"""
        m, n = len(image), len(image[0])
        left = self.searchColumns(image, 0, y, 0, m, True)
        right = self.searchColumns(image, y, n, 0, m, False)
        top = self.searchRows(image, 0, x, 0, n, True)
        bottom = self.searchRows(image, x, m, 0, n, False)
        return (right - left) * (bottom - top)
    
    def searchColumns(self, image, start, end, top, bottom, isLeft):
        while start < end:
            mid = start + (end - start) // 2
            if self.hasBlackPixel(image, top, bottom, mid, isLeft):
                end = mid
            else:
                start = mid + 1
        return start
    
    def searchRows(self, image, start, end, left, right, isTop):
        while start < end:
            mid = start + (end - start) // 2
            if self.hasBlackPixel(image, left, right, mid, isTop):
                end = mid
            else:
                start = mid + 1
        return start
    
    def hasBlackPixel(self, image, i, j, mid, isRow):
        if isRow:
            while i < j:
                if image[i][mid] == '1':
                    return True
                i += 1
        else:
            while i < j:
                if image[mid][i] == '1':
                    return True
                i += 1
        return False
","Runtime Error
0 / 111 testcases passed
IndexError: list index out of range
    if image[mid][i] == '1':
Line 42 in hasBlackPixel (Solution.py)
    if self.hasBlackPixel(image, top, bottom, mid, isLeft):
Line 19 in searchColumns (Solution.py)
    right = self.searchColumns(image, y, n, 0, m, False)
Line 11 in minArea (Solution.py)
    ret = Solution().minArea(param_1, param_2, param_3)
Line 75 in _driver (Solution.py)
    _driver()
Line 85 in <module> (Solution.py)
Last Executed Input
Use Testcase

image =
[[""0"",""0"",""1"",""0""],[""0"",""1"",""1"",""0""],[""0"",""1"",""0"",""0""]]
x =
0

y =
2

","class Solution(object):
    def minArea(self, image, x, y):
        """"""
        :type image: List[List[str]]
        :type x: int
        :type y: int
        :rtype: int
        """"""
        m, n = len(image), len(image[0])
        left = self.searchColumns(image, 0, y, 0, m, True)
        right = self.searchColumns(image, y + 1, n, 0, m, False)
        top = self.searchRows(image, 0, x, 0, n, True)
        bottom = self.searchRows(image, x + 1, m, 0, n, False)
        return (right - left) * (bottom - top)
    
    def searchColumns(self, image, start, end, top, bottom, isLeft):
        while start < end:
            mid = start + (end - start) // 2
            if self.hasBlackPixel(image, top, bottom, mid, isLeft):
                end = mid
            else:
                start = mid + 1
        return start
    
    def searchRows(self, image, start, end, left, right, isTop):
        while start < end:
            mid = start + (end - start) // 2
            if self.hasBlackPixel(image, left, right, mid, isTop):
                end = mid
            else:
                start = mid + 1
        return start
    
    def hasBlackPixel(self, image, i, j, mid, isRow):
        if isRow:
            while i < j:
                if image[mid][i] == '1':
                    return True
                i += 1
        else:
            while i < j:
                if image[i][mid] == '1':
                    return True
                i += 1
        return False
","Wrong Answer

5 / 111 testcases passed
Input
image =
[[""0"",""0"",""1"",""0""],[""0"",""1"",""1"",""0""],[""0"",""1"",""0"",""0""]]
x =
0
y =
2
Use Testcase

Output
4
Expected
6


","class Solution(object):
    def minArea(self, image, x, y):
        """"""
        :type image: List[List[str]]
        :type x: int
        :type y: int
        :rtype: int
        """"""
        m, n = len(image), len(image[0])
        left = self.searchColumns(image, 0, y, 0, m, True)
        right = self.searchColumns(image, y, n, 0, m, False)
        top = self.searchRows(image, 0, x, 0, n, True)
        bottom = self.searchRows(image, x, m, 0, n, False)
        return (right - left + 1) * (bottom - top + 1)
    
    def searchColumns(self, image, start, end, top, bottom, isLeft):
        while start < end:
            mid = (start + end) // 2
            if self.hasBlackPixel(image, top, bottom, mid, isLeft):
                end = mid
            else:
                start = mid + 1
        return start
    
    def searchRows(self, image, start, end, left, right, isTop):
        while start < end:
            mid = (start + end) // 2
            if self.hasBlackPixel(image, left, right, mid, isTop):
                end = mid
            else:
                start = mid + 1
        return start
    
    def hasBlackPixel(self, image, i, j, mid, isRow):
        if isRow:
            while i < j:
                if image[mid][i] == '1':
                    return True
                i += 1
        else:
            while i < j:
                if image[i][mid] == '1':
                    return True
                i += 1
        return False
","Runtime Error
0 / 111 testcases passed
IndexError: list index out of range
    if image[i][mid] == '1':
Line 42 in hasBlackPixel (Solution.py)
    if self.hasBlackPixel(image, left, right, mid, isTop):
Line 28 in searchRows (Solution.py)
    bottom = self.searchRows(image, x, m, 0, n, False)
Line 13 in minArea (Solution.py)
    ret = Solution().minArea(param_1, param_2, param_3)
Line 75 in _driver (Solution.py)
    _driver()
Line 85 in <module> (Solution.py)
Last Executed Input
Use Testcase

image =
[[""0"",""0"",""1"",""0""],[""0"",""1"",""1"",""0""],[""0"",""1"",""0"",""0""]]
x =
0

y =
2

","class Solution(object):
    def minArea(self, image, x, y):
        """"""
        :type image: List[List[str]]
        :type x: int
        :type y: int
        :rtype: int
        """"""
        m, n = len(image), len(image[0])
        left = self.searchColumns(image, 0, y, 0, m, True)
        right = self.searchColumns(image, y, n, 0, m, False)
        top = self.searchRows(image, 0, x, 0, n, True)
        bottom = self.searchRows(image, x, m, 0, n, False)
        return (right - left + 1) * (bottom - top + 1)
    
    def searchColumns(self, image, start, end, top, bottom, isLeft):
        while start < end:
            mid = (start + end) // 2
            if self.hasBlackPixel(image, top, bottom, mid, isLeft):
                end = mid
            else:
                start = mid + 1
        return start
    
    def searchRows(self, image, start, end, left, right, isTop):
        while start < end:
            mid = (start + end) // 2
            if self.hasBlackPixel(image, left, right, mid, isTop):
                end = mid
            else:
                start = mid + 1
        return start
    
    def hasBlackPixel(self, image, i, j, mid, isRow):
        if isRow:
            while i < j:
                if image[mid][i] == '1':
                    return True
                i += 1
        else:
            while i < j:
                if image[i][mid] == '1':
                    return True
                i += 1
        return False
","Runtime Error
0 / 111 testcases passed
IndexError: list index out of range
    if image[i][mid] == '1':
Line 42 in hasBlackPixel (Solution.py)
    if self.hasBlackPixel(image, left, right, mid, isTop):
Line 28 in searchRows (Solution.py)
    bottom = self.searchRows(image, x, m, 0, n, False)
Line 13 in minArea (Solution.py)
    ret = Solution().minArea(param_1, param_2, param_3)
Line 75 in _driver (Solution.py)
    _driver()
Line 85 in <module> (Solution.py)
Last Executed Input
Use Testcase

image =
[[""0"",""0"",""1"",""0""],[""0"",""1"",""1"",""0""],[""0"",""1"",""0"",""0""]]
x =
0

y =
2
",,,,,,,,,,,,
45,Hard,123,"class Solution(object):
    def maxProfit(self, prices):
        if not prices:
            return 0

        # Initialize the buy and sell arrays
        buy = [float('-inf')] * 3
        sell = [0] * 3

        for price in prices:
            for i in range(1, 3):
                # Update the maximum profit achievable by buying at the current price
                # or not buying at all (using the maximum profit from the previous day)
                buy[i] = max(buy[i], sell[i - 1] - price)

                # Update the maximum profit achievable by selling at the current price
                # or not selling at all (using the maximum profit from the previous day)
                sell[i] = max(sell[i], buy[i] + price)

        # The maximum profit will be the maximum value in the sell array
        return sell[-1]
",,,,,,,,,,,,"32.13, 82.38","class Solution(object):
    def maxProfit(self, prices):
        if not prices:
            return 0

        # Initialize the buy and sell variables
        buy1 = buy2 = float('-inf')
        sell1 = sell2 = 0

        for price in prices:
            # Update the maximum profit achievable by buying at the current price
            # or not buying at all (using the maximum profit from the previous day)
            buy1 = max(buy1, -price)

            # Update the maximum profit achievable by selling at the current price
            # or not selling at all (using the maximum profit from the previous day)
            sell1 = max(sell1, buy1 + price)

            # Update the maximum profit achievable by buying at the current price
            # or not buying at all (using the maximum profit from the previous day)
            buy2 = max(buy2, sell1 - price)

            # Update the maximum profit achievable by selling at the current price
            # or not selling at all (using the maximum profit from the previous day)
            sell2 = max(sell2, buy2 + price)

        # The maximum profit will be the maximum value in the sell2 variable
        return sell2
","62.18, 82.38","class Solution(object):
    def maxProfit(self, prices):
        if not prices:
            return 0

        buy1 = buy2 = float('-inf')
        sell1 = sell2 = 0

        for price in prices:
            # Update the first buy and sell variables
            buy1 = max(buy1, -price)
            sell1 = max(sell1, buy1 + price)

            # Update the second buy and sell variables
            buy2 = max(buy2, sell1 - price)
            sell2 = max(sell2, buy2 + price)

        return sell2
","61.14, 88.6",X,,,,,,
46,Hard,2328,"class Solution(object):
    def countPaths(self, grid):
        MOD = int(1e9) + 7
        m, n = len(grid), len(grid[0])
        
        dp = [[1] * n for _ in range(m)]
        
        for i in range(m-1, -1, -1):
            for j in range(n-1, -1, -1):
                for ni, nj in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:
                    if 0 <= ni < m and 0 <= nj < n and grid[ni][nj] > grid[i][j]:
                        dp[i][j] = (dp[i][j] + dp[ni][nj]) % MOD
        
        ans = 0
        for i in range(m):
            for j in range(n):
                ans = (ans + dp[i][j]) % MOD
        
        return ans
","Wrong Answer

6 / 36 testcases passed
Input
grid =
[[12469,18741,68716,30594,65029,44019,92944,84784,92781,5655,43120,81333,54113,88220,23446,6129,2904,48677,20506,79604,82841,3938,46511,60870,10825,31759,78612,19776,43160,86915,74498,38366,28228,23687,40729,42613,61154,22726,51028,45603,53586,44657,97573,61067,27187,4619,6135,24668,69634,24564,30255,51939,67573,87012,4106,76312,28737,7704,35798]]
Use Testcase

Output
135
Expected
148


","class Solution(object):
    def countPaths(self, grid):
        MOD = int(1e9) + 7
        m, n = len(grid), len(grid[0])
        
        dp = [[0] * n for _ in range(m)]
        
        def dfs(i, j):
            if dp[i][j] > 0:
                return dp[i][j]
            
            count = 1
            for ni, nj in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:
                if 0 <= ni < m and 0 <= nj < n and grid[ni][nj] > grid[i][j]:
                    count = (count + dfs(ni, nj)) % MOD
            
            dp[i][j] = count
            return count
        
        ans = 0
        for i in range(m):
            for j in range(n):
                ans = (ans + dfs(i, j)) % MOD
        
        return ans
",,,,,,,,,,"93.75, 87.50","class Solution(object):
    def countPaths(self, grid):
        MOD = int(1e9) + 7
        m, n = len(grid), len(grid[0])

        dp = [[-1] * n for _ in range(m)]

        def dfs(i, j):
            if dp[i][j] != -1:
                return dp[i][j]

            count = 1
            for ni, nj in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:
                if 0 <= ni < m and 0 <= nj < n and grid[ni][nj] > grid[i][j]:
                    count = (count + dfs(ni, nj)) % MOD

            dp[i][j] = count
            return count

        ans = 0
        for i in range(m):
            for j in range(n):
                ans = (ans + dfs(i, j)) % MOD

        return ans
","87.5, 87.5","class Solution(object):
    def countPaths(self, grid):
        MOD = int(1e9) + 7
        m, n = len(grid), len(grid[0])

        dp = [[0] * n for _ in range(m)]
        dp[m-1][n-1] = 1

        for i in range(m-1, -1, -1):
            for j in range(n-1, -1, -1):
                for ni, nj in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:
                    if 0 <= ni < m and 0 <= nj < n and grid[ni][nj] > grid[i][j]:
                        dp[i][j] = (dp[i][j] + dp[ni][nj]) % MOD

        return dp[0][0]
",,,,,,,,"Wrong Answer

0 / 36 testcases passed
Input
grid =
[[1,1],[3,4]]
Use Testcase

Output
1
Expected
8


"
47,Hard,2444,"class Solution(object):
    def countSubarrays(self, nums, minK, maxK):
        """"""
        :type nums: List[int]
        :type minK: int
        :type maxK: int
        :rtype: int
        """"""
        n = len(nums)
        count = 0
        left = -1
        right = -1
        
        for i in range(n):
            if nums[i] >= minK and nums[i] <= maxK:
                right = i
                count += right - left
            elif nums[i] < minK:
                left = i
                right = i
                
        left = -1
        right = -1
        
        for i in range(n-1, -1, -1):
            if nums[i] >= minK and nums[i] <= maxK:
                left = i
                count += right - left
            elif nums[i] > maxK:
                right = i
                left = i
                
        return count
","Wrong Answer

2 / 51 testcases passed
Input
nums =
[1,3,5,2,7,5]
minK =
1
maxK =
5
Use Testcase

Output
20
Expected
2


","class Solution(object):
    def countSubarrays(self, nums, minK, maxK):
        """"""
        :type nums: List[int]
        :type minK: int
        :type maxK: int
        :rtype: int
        """"""
        n = len(nums)
        count = 0
        prefix_count = 0
        left = 0
        
        for right in range(n):
            if nums[right] >= minK and nums[right] <= maxK:
                prefix_count = right - left + 1
                count += prefix_count
            elif nums[right] < minK:
                prefix_count = 0
                left = right + 1
            else:
                left = right + 1
                
        return count
","Wrong Answer

6 / 51 testcases passed
Input
nums =
[1,3,5,2,7,5]
minK =
1
maxK =
5
Use Testcase

Output
11
Expected
2


","class Solution(object):
    def countSubarrays(self, nums, minK, maxK):
        """"""
        :type nums: List[int]
        :type minK: int
        :type maxK: int
        :rtype: int
        """"""
        n = len(nums)
        count = 0
        left = -1
        right = -1
        
        for i in range(n):
            if nums[i] >= minK and nums[i] <= maxK:
                right = i
                count += right - left
            elif nums[i] < minK:
                left = i
                right = i
            else:
                left = i
        
        return count
","Wrong Answer

6 / 51 testcases passed
Input
nums =
[1,3,5,2,7,5]
minK =
1
maxK =
5
Use Testcase

Output
11
Expected
2


","class Solution(object):
    def countSubarrays(self, nums, minK, maxK):
        """"""
        :type nums: List[int]
        :type minK: int
        :type maxK: int
        :rtype: int
        """"""
        count = 0
        start = 0
        end = 0
        n = len(nums)
        
        while start < n:
            if nums[start] >= minK and nums[start] <= maxK:
                end = start
                while end < n and nums[end] >= minK and nums[end] <= maxK:
                    end += 1
                count += (end - start) * (end - start + 1) // 2
                start = end
            else:
                start += 1
        
        return count
","Wrong Answer

6 / 51 testcases passed
Input
nums =
[1,3,5,2,7,5]
minK =
1
maxK =
5
Use Testcase

Output
11
Expected
2


","class Solution(object):
    def countSubarrays(self, nums, minK, maxK):
        """"""
        :type nums: List[int]
        :type minK: int
        :type maxK: int
        :rtype: int
        """"""
        count = 0
        n = len(nums)
        
        for i in range(n):
            if nums[i] <= maxK:
                left = i
                while left < n and nums[left] >= minK:
                    count += 1
                    left += 1
        
        return count
","Wrong Answer

1 / 51 testcases passed
Input
nums =
[1,3,5,2,7,5]
minK =
1
maxK =
5
Use Testcase

Output
19
Expected
2


","class Solution(object):
    def countSubarrays(self, nums, minK, maxK):
        """"""
        :type nums: List[int]
        :type minK: int
        :type maxK: int
        :rtype: int
        """"""
        count = 0
        n = len(nums)
        start = 0
        
        while start < n:
            if nums[start] > maxK:
                start += 1
                continue
            
            end = start
            while end < n and nums[end] <= maxK:
                if nums[end] >= minK:
                    count += 1
                end += 1
            
            start = end + 1
        
        return count
","Wrong Answer

4 / 51 testcases passed
Input
nums =
[1,3,5,2,7,5]
minK =
1
maxK =
5
Use Testcase

Output
5
Expected
2


",,,,,,,,,,,,
48,Hard,1591,"class Solution(object):
    def isPrintable(self, targetGrid):
        m, n = len(targetGrid), len(targetGrid[0])
        colors = set()

        def is_valid(start_row, start_col, end_row, end_col, color):
            for i in range(start_row, end_row + 1):
                for j in range(start_col, end_col + 1):
                    if targetGrid[i][j] == 0 or targetGrid[i][j] == color:
                        continue
                    elif targetGrid[i][j] != color:
                        return False
            return True

        def erase(start_row, start_col, end_row, end_col):
            for i in range(start_row, end_row + 1):
                for j in range(start_col, end_col + 1):
                    targetGrid[i][j] = 0

        def backtrack():
            if not colors:
                return True

            for color in list(colors):
                min_row, min_col, max_row, max_col = float('inf'), float('inf'), float('-inf'), float('-inf')
                for i in range(m):
                    for j in range(n):
                        if targetGrid[i][j] == color:
                            min_row = min(min_row, i)
                            min_col = min(min_col, j)
                            max_row = max(max_row, i)
                            max_col = max(max_col, j)

                if is_valid(min_row, min_col, max_row, max_col, color):
                    erase(min_row, min_col, max_row, max_col)
                    colors.remove(color)
                    if backtrack():
                        return True
                    colors.add(color)
                    for i in range(min_row, max_row + 1):
                        for j in range(min_col, max_col + 1):
                            if targetGrid[i][j] == 0:
                                targetGrid[i][j] = color
                else:
                    return False

            return False

        for i in range(m):
            for j in range(n):
                colors.add(targetGrid[i][j])

        return backtrack()
","Wrong Answer

77 / 153 testcases passed
Input
targetGrid =
[[1,1,1,1],[1,2,2,1],[1,2,2,1],[1,1,1,1]]
Use Testcase

Output
false
Expected
true


","class Solution(object):
    def isPrintable(self, targetGrid):
        m, n = len(targetGrid), len(targetGrid[0])
        colors = set()

        def is_valid(start_row, start_col, end_row, end_col, color):
            for i in range(start_row, end_row + 1):
                for j in range(start_col, end_col + 1):
                    if targetGrid[i][j] == 0 or targetGrid[i][j] == color:
                        continue
                    elif targetGrid[i][j] != color and targetGrid[i][j] in colors:
                        return False
            return True

        def erase(start_row, start_col, end_row, end_col):
            for i in range(start_row, end_row + 1):
                for j in range(start_col, end_col + 1):
                    targetGrid[i][j] = 0

        def backtrack():
            if not colors:
                return True

            for color in list(colors):
                min_row, min_col, max_row, max_col = float('inf'), float('inf'), float('-inf'), float('-inf')
                for i in range(m):
                    for j in range(n):
                        if targetGrid[i][j] == color:
                            min_row = min(min_row, i)
                            min_col = min(min_col, j)
                            max_row = max(max_row, i)
                            max_col = max(max_col, j)

                if is_valid(min_row, min_col, max_row, max_col, color):
                    erase(min_row, min_col, max_row, max_col)
                    colors.remove(color)
                    if backtrack():
                        return True
                    colors.add(color)
                    for i in range(min_row, max_row + 1):
                        for j in range(min_col, max_col + 1):
                            if targetGrid[i][j] == 0:
                                targetGrid[i][j] = color
                else:
                    return False

            return False

        for i in range(m):
            for j in range(n):
                colors.add(targetGrid[i][j])

        return backtrack()
","Wrong Answer

77 / 153 testcases passed
Input
targetGrid =
[[1,1,1,1],[1,2,2,1],[1,2,2,1],[1,1,1,1]]
Use Testcase

Output
false
Expected
true


","class Solution(object):
    def isPrintable(self, targetGrid):
        m, n = len(targetGrid), len(targetGrid[0])
        colors = set()

        def is_valid(start_row, start_col, end_row, end_col, color):
            for i in range(start_row, end_row + 1):
                for j in range(start_col, end_col + 1):
                    if targetGrid[i][j] == 0 or targetGrid[i][j] == color:
                        continue
                    elif targetGrid[i][j] != color and targetGrid[i][j] in colors:
                        return False
                    elif targetGrid[i][j] != color and targetGrid[i][j] not in colors:
                        return True
            return True

        def erase(start_row, start_col, end_row, end_col):
            for i in range(start_row, end_row + 1):
                for j in range(start_col, end_col + 1):
                    targetGrid[i][j] = 0

        def backtrack():
            if not colors:
                return True

            for color in list(colors):
                min_row, min_col, max_row, max_col = float('inf'), float('inf'), float('-inf'), float('-inf')
                for i in range(m):
                    for j in range(n):
                        if targetGrid[i][j] == color:
                            min_row = min(min_row, i)
                            min_col = min(min_col, j)
                            max_row = max(max_row, i)
                            max_col = max(max_col, j)

                if is_valid(min_row, min_col, max_row, max_col, color):
                    erase(min_row, min_col, max_row, max_col)
                    colors.remove(color)
                    if backtrack():
                        return True
                    colors.add(color)
                    for i in range(min_row, max_row + 1):
                        for j in range(min_col, max_col + 1):
                            if targetGrid[i][j] == 0:
                                targetGrid[i][j] = color
                else:
                    return False

            return False

        for i in range(m):
            for j in range(n):
                colors.add(targetGrid[i][j])

        return backtrack()
","Wrong Answer

77 / 153 testcases passed
Input
targetGrid =
[[1,1,1,1],[1,2,2,1],[1,2,2,1],[1,1,1,1]]
Use Testcase

Output
false
Expected
true


","class Solution(object):
    def isPrintable(self, targetGrid):
        m, n = len(targetGrid), len(targetGrid[0])
        colors = set()
        visited = set()

        def is_valid(start_row, start_col, end_row, end_col, color):
            for i in range(start_row, end_row + 1):
                for j in range(start_col, end_col + 1):
                    if targetGrid[i][j] == color or (i, j) in visited:
                        continue
                    elif targetGrid[i][j] != 0 and targetGrid[i][j] != color:
                        return False
            return True

        def erase(start_row, start_col, end_row, end_col):
            for i in range(start_row, end_row + 1):
                for j in range(start_col, end_col + 1):
                    targetGrid[i][j] = 0

        def backtrack():
            if not colors:
                return True

            for color in list(colors):
                min_row, min_col, max_row, max_col = float('inf'), float('inf'), float('-inf'), float('-inf')
                for i in range(m):
                    for j in range(n):
                        if targetGrid[i][j] == color and (i, j) not in visited:
                            min_row = min(min_row, i)
                            min_col = min(min_col, j)
                            max_row = max(max_row, i)
                            max_col = max(max_col, j)

                if is_valid(min_row, min_col, max_row, max_col, color):
                    erase(min_row, min_col, max_row, max_col)
                    visited.update((i, j) for i in range(min_row, max_row + 1) for j in range(min_col, max_col + 1))
                    colors.remove(color)
                    if backtrack():
                        return True
                    colors.add(color)
                    visited.difference_update((i, j) for i in range(min_row, max_row + 1) for j in range(min_col, max_col + 1))
                    for i in range(min_row, max_row + 1):
                        for j in range(min_col, max_col + 1):
                            if targetGrid[i][j] == 0 and (i, j) not in visited:
                                targetGrid[i][j] = color
                else:
                    return False

            return False

        for i in range(m):
            for j in range(n):
                colors.add(targetGrid[i][j])

        return backtrack()
","Wrong Answer

77 / 153 testcases passed
Input
targetGrid =
[[1,1,1,1],[1,2,2,1],[1,2,2,1],[1,1,1,1]]
Use Testcase

Output
false
Expected
true


","class Solution(object):
    def isPrintable(self, targetGrid):
        m, n = len(targetGrid), len(targetGrid[0])
        colors = set()
        visited = set()

        def is_valid(start_row, start_col, end_row, end_col, color):
            for i in range(start_row, end_row + 1):
                for j in range(start_col, end_col + 1):
                    if targetGrid[i][j] == color:
                        continue
                    elif targetGrid[i][j] != 0 and targetGrid[i][j] != color and (i, j) not in visited:
                        return False
            return True

        def erase(start_row, start_col, end_row, end_col):
            for i in range(start_row, end_row + 1):
                for j in range(start_col, end_col + 1):
                    targetGrid[i][j] = 0

        def backtrack():
            if not colors:
                return True

            for color in list(colors):
                min_row, min_col, max_row, max_col = float('inf'), float('inf'), float('-inf'), float('-inf')
                for i in range(m):
                    for j in range(n):
                        if targetGrid[i][j] == color and (i, j) not in visited:
                            min_row = min(min_row, i)
                            min_col = min(min_col, j)
                            max_row = max(max_row, i)
                            max_col = max(max_col, j)

                if is_valid(min_row, min_col, max_row, max_col, color):
                    erase(min_row, min_col, max_row, max_col)
                    visited.update((i, j) for i in range(min_row, max_row + 1) for j in range(min_col, max_col + 1))
                    colors.remove(color)
                    if backtrack():
                        return True
                    colors.add(color)
                    visited.difference_update((i, j) for i in range(min_row, max_row + 1) for j in range(min_col, max_col + 1))
                    for i in range(min_row, max_row + 1):
                        for j in range(min_col, max_col + 1):
                            if targetGrid[i][j] == 0 and (i, j) not in visited:
                                targetGrid[i][j] = color
                else:
                    return False

            return False

        for i in range(m):
            for j in range(n):
                colors.add(targetGrid[i][j])

        return backtrack()
","Wrong Answer

77 / 153 testcases passed
Input
targetGrid =
[[1,1,1,1],[1,2,2,1],[1,2,2,1],[1,1,1,1]]
Use Testcase

Output
false
Expected
true


","class Solution(object):
    def isPrintable(self, targetGrid):
        m, n = len(targetGrid), len(targetGrid[0])
        colors = set()
        visited = set()

        def is_valid(start_row, start_col, end_row, end_col, color):
            for i in range(start_row, end_row + 1):
                for j in range(start_col, end_col + 1):
                    if targetGrid[i][j] == color:
                        continue
                    elif targetGrid[i][j] != 0 and targetGrid[i][j] != color and (i, j) not in visited:
                        return False
            return True

        def erase(start_row, start_col, end_row, end_col):
            for i in range(start_row, end_row + 1):
                for j in range(start_col, end_col + 1):
                    targetGrid[i][j] = 0

        def backtrack():
            if not colors:
                return True

            for color in list(colors):
                min_row, min_col, max_row, max_col = float('inf'), float('inf'), float('-inf'), float('-inf')
                for i in range(m):
                    for j in range(n):
                        if targetGrid[i][j] == color and (i, j) not in visited:
                            min_row = min(min_row, i)
                            min_col = min(min_col, j)
                            max_row = max(max_row, i)
                            max_col = max(max_col, j)

                if is_valid(min_row, min_col, max_row, max_col, color):
                    erase(min_row, min_col, max_row, max_col)
                    visited.update((i, j) for i in range(min_row, max_row + 1) for j in range(min_col, max_col + 1))
                    colors.remove(color)
                    if backtrack():
                        return True
                    colors.add(color)
                    visited.difference_update((i, j) for i in range(min_row, max_row + 1) for j in range(min_col, max_col + 1))
                    for i in range(min_row, max_row + 1):
                        for j in range(min_col, max_col + 1):
                            if targetGrid[i][j] == 0 and (i, j) not in visited:
                                targetGrid[i][j] = color
                else:
                    return False

            return False

        for i in range(m):
            for j in range(n):
                colors.add(targetGrid[i][j])

        while colors:
            if not backtrack():
                return False

        return True
","Wrong Answer

77 / 153 testcases passed
Input
targetGrid =
[[1,1,1,1],[1,2,2,1],[1,2,2,1],[1,1,1,1]]
Use Testcase

Output
false
Expected
true


",,,,,,,,,,,,
49,Hard,1835,"class Solution(object):
    def getXORSum(self, arr1, arr2):
        xor_sum_arr1 = 0
        xor_sum_arr2 = 0
        
        # Calculate XOR sum of arr1
        for num in arr1:
            xor_sum_arr1 ^= num
        
        # Calculate XOR sum of arr2
        for num in arr2:
            xor_sum_arr2 ^= num
        
        # Return the XOR sum of both arrays
        return xor_sum_arr1 & xor_sum_arr2
",,,,,,,,,,,,"20, 100","class Solution(object):
    def getXORSum(self, arr1, arr2):
        xor_sum = 0
        
        for num1 in arr1:
            for num2 in arr2:
                xor_sum ^= num1 & num2
        
        return xor_sum
",,,,,,,,,,"Time Limit Exceeded
74 / 84 testcases passed
Last Executed Input
Use Testcase

arr1 =
[1898,227,9397,3017,7978,5631,4125,5093,1465,3441,8983,2309,4141,3907,1568,9327,4899,8568,6821,5274,9472,9100,5843,2541,8582,7523,8281,3731,5125,3399,9075,5386,2102,8897,2254,6475,4616,606,480,562,6664,6012,698,8216,7557,9472,7466,8260,4848,8910,6543,6621,5414,4149,7978,1309,328,2450,5176,1059,5897,895,992,6283,5275,3537,2275,7020,3829,4642,5581,79,3684,3485,4342,6626,4927,7708,6643,7989,9735,7636,4323,276,7640,7347,7453,8648,6979,3571,9764,5998,7166,2786,2856,9279,7489,9047,5799,8515,377,3525,1816,6120,659,7351,1067,5330,1589,1491,8510,5986,3745,1485,5451,2113,3986,5759,3840,4382,4017,8348,6401,9516,599,236,4260,4588,8166,1905,7969,6749,4584,1585,1011,5635,7994,6019,8795,9847,4331,3286,7020,6270...
View all 


arr2 =
[7767,8993,9553,6638,465,1797,7652,6724,5601,5441,7236,1149,9573,2575,280,4970,2013,8470,2903,8648,7048,5955,7609,821,5813,5040,6197,2550,2188,648,8079,3660,9864,6184,5961,7451,7935,2124,471,5285,6828,9172,8642,7797,9729,418,8430,5950,1243,90,2793,4729,3563,6330,4404,3813,3513,4162,7182,9769,2595,2272,5658,374,8350,1538,7988,2500,1632,4816,6162,9528,6410,4215,6717,5329,70,6819,7250,4070,55,5193,8928,3941,5253,3914,7721,2361,7906,656,3642,3624,3045,7392,3672,495,4088,749,6530,8273,2423,5844,4488,8535,4519,9504,2825,6303,7587,4548,8590,5783,8792,7880,3500,7609,212,1950,6617,7434,3363,7539,1666,807,3190,8023,5522,3251,3370,234,7336,5946,4997,9731,797,7367,870,7054,1255,3666,7189,5297,2787,9701,5357,89...
View all 


"
50,Hard,502,"import heapq

class Solution(object):
    def findMaximizedCapital(self, k, w, profits, capital):
        """"""
        :type k: int
        :type w: int
        :type profits: List[int]
        :type capital: List[int]
        :rtype: int
        """"""
        n = len(profits)
        projects = [(capital[i], profits[i]) for i in range(n)]
        projects.sort(key=lambda x: x[0])  # Sort projects by capital in ascending order

        available = []  # Projects that have enough capital to start
        i = 0

        for _ in range(k):
            while i < n and projects[i][0] <= w:
                heapq.heappush(available, -projects[i][1])  # Use a max heap to store negative profits
                i += 1

            if available:
                w -= heapq.heappop(available)
            else:
                break

        return w
",,,,,,,,,,,,"49.37, 31.65","import heapq

class Solution(object):
    def findMaximizedCapital(self, k, w, profits, capital):
        """"""
        :type k: int
        :type w: int
        :type profits: List[int]
        :type capital: List[int]
        :rtype: int
        """"""
        n = len(profits)
        projects = [(capital[i], profits[i]) for i in range(n)]
        projects.sort(reverse=True)  # Sort projects by capital in descending order

        available = []  # Projects that have enough capital to start
        i = 0

        for _ in range(k):
            while i < n and projects[i][0] <= w:
                heapq.heappush(available, -projects[i][1])  # Use a max heap to store negative profits
                i += 1

            if available:
                w -= heapq.heappop(available)
            elif i == n:
                break

            if not available and i < n:
                # No more available projects and there are remaining projects
                # Find the project with the maximum capital requirement
                max_capital = projects[i][0]
                while i < n and projects[i][0] == max_capital:
                    heapq.heappush(available, -projects[i][1])
                    i += 1

        return w
",,,,,,,,,,"Wrong Answer

9 / 35 testcases passed
Input
k =
2
w =
0
profits =
[1,2,3]
capital =
[0,1,1]
Use Testcase

Output
3
Expected
4


"
51,Hard,1157,"import collections

class MajorityChecker(object):

    def __init__(self, arr):
        """"""
        :type arr: List[int]
        """"""
        self.arr = arr
        self.counts = collections.defaultdict(list)
        for i, num in enumerate(arr):
            self.counts[num].append(i)

    def query(self, left, right, threshold):
        """"""
        :type left: int
        :type right: int
        :type threshold: int
        :rtype: int
        """"""
        for _ in range(10):
            num = self.arr[random.randint(left, right)]
            indices = self.counts[num]
            if len(indices) < threshold:
                continue
            left_idx = bisect_left(indices, left)
            right_idx = bisect_right(indices, right)
            if right_idx - left_idx >= threshold:
                return num
        return -1
",,,,,,,,,,,,"100, 88.24","class MajorityChecker(object):

    def __init__(self, arr):
        """"""
        :type arr: List[int]
        """"""
        self.arr = arr
        self.counts = collections.defaultdict(list)
        for i, num in enumerate(arr):
            self.counts[num].append(i)

    def query(self, left, right, threshold):
        """"""
        :type left: int
        :type right: int
        :type threshold: int
        :rtype: int
        """"""
        for _ in range(10):
            num = self.arr[random.randint(left, right)]
            count = self.count_occurrences(num, left, right)
            if count >= threshold:
                return num
        return -1

    def count_occurrences(self, num, left, right):
        count = 0
        for i in range(left, right + 1):
            if self.arr[i] == num:
                count += 1
        return count
",,,,,,,,,,"Time Limit Exceeded
21 / 36 testcases passed
Last Executed Input
Use Testcase

[""MajorityChecker"",""query"",""query"",""query"",""query"",""query"",""query"",""query"",""query"",""query"",""query"",""query"",""query"",""query"",""query"",""query"",""query"",""query"",""query"",""query"",""query"",""query"",""query"",""query"",""query"",""query"",""query"",""query"",""query"",""query"",""query"",""query"",""query"",""query"",""query"",""query"",""query"",""query"",""query"",""query"",""query"",""query"",""query"",""query"",""query"",""query"",""query"",""query"",""query"",""query"",""query"",""query"",""query"",""query"",""query"",""query"",""query"",""query"",""query"",""query"",""query"",""query"",""query"",""query"",""query"",""query"",""query"",""query"",""query"",""query"",""query"",""query"",""query"",""query"",""query"",""query"",""query"",""query"",""query"",""query"",""query"",""query"",""query"",""query"",""query"",""query"",""qu...
View all 


[[[2,4,2,2,9,8,10,4,6,3,6,7,4,7,6,7,8,6,3,6,1,9,2,10,8,9,7,2,3,10,10,2,7,8,3,2,2,9,6,10,2,9,5,5,1,2,9,8,5,4,10,8,2,6,7,4,1,4,9,3,1,4,8,10,4,10,4,10,2,4,3,2,3,9,4,2,10,10,2,6,10,1,4,2,6,1,10,7,6,8,3,7,4,10,5,4,1,5,10,5,5,4,6,9,4,1,1,5,9,9,8,6,10,3,9,8,10,7,8,7,6,9,10,8,6,5,6,2,4,9,6,1,10,5,3,3,6,10,5,7,10,6,6,1,4,5,8,2,5,8,10,1,8,1,3,4,5,6,8,5,8,7,6,9,7,7,1,4,10,3,7,1,2,3,9,7,1,8,4,6,6,5,3,5,6,10,8,6,1,4,6,8,3,7,4,2,9,9,3,8,4,2,2,3,2,6,5,9,3,3,4,7,2,7,2,3,8,3,4,2,5,4,7,8,2,6,9,7,2,7,2,10,3,1,1,1,4,10,2,5,6,6,3,7,8,4,9,6,4,4,5,7,2,5,9,2,10,10,3,8,3,6,8,1,7,1,4,2,4,6,8,2,1,6,7,6,3,1,4,1,10,6,1,4,7,10,8,9,1,1,7,4,6,9,7,6,10,1,5,6,10,7,4,4,5,7,1,7,9,3,10,8,5,2,7,7,7,2,4,1,10,3,10,7,9,3,2,9,8,6,5,2,4...
View all 


"
52,Hard,1163,"class Solution(object):
    def lastSubstring(self, s):
        """"""
        :type s: str
        :rtype: str
        """"""
        max_char = max(s)
        max_substrings = [i for i, c in enumerate(s) if c == max_char]
        
        max_substring = s[max_substrings[0]:]
        for i in range(1, len(max_substrings)):
            substring = s[max_substrings[i]:]
            if substring > max_substring:
                max_substring = substring
        
        return max_substring
","Time Limit Exceeded
25 / 34 testcases passed
Last Executed Input
Use Testcase


s =
""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...
View all 


","class Solution(object):
    def lastSubstring(self, s):
        """"""
        :type s: str
        :rtype: str
        """"""
        n = len(s)
        i, j, k = 0, 1, 0
        
        while j + k < n:
            if s[i + k] == s[j + k]:
                k += 1
                continue
            elif s[i + k] > s[j + k]:
                j = j + k + 1
            else:
                i = max(i + k + 1, j)
                j = i + 1
            k = 0
        
        return s[i:]
",,,,,,,,,,"50, 70","class Solution(object):
    def lastSubstring(self, s):
        """"""
        :type s: str
        :rtype: str
        """"""
        n = len(s)
        i, j, k = 0, 1, 0

        while j + k < n:
            if s[i + k] == s[j + k]:
                k += 1
            elif s[i + k] < s[j + k]:
                i = j
                j += 1
                k = 0
            else:
                j = j + k + 1
                k = 0

        return s[i:]
",,,,,,,,,,"Time Limit Exceeded
27 / 34 testcases passed
Last Executed Input
Use Testcase


s =
""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...
View all 
"
53,Hard,1568,"class Solution(object):
    def minDays(self, grid):
        """"""
        :type grid: List[List[int]]
        :rtype: int
        """"""
        m, n = len(grid), len(grid[0])
        if self.countIslands(grid) != 1:
            return 0
        
        for i in range(m):
            for j in range(n):
                if grid[i][j] == 1:
                    grid[i][j] = 0
                    if self.countIslands(grid) != 1:
                        return 1
                    grid[i][j] = 1
        return 2
    
    def countIslands(self, grid):
        m, n = len(grid), len(grid[0])
        visited = [[False] * n for _ in range(m)]
        count = 0
        for i in range(m):
            for j in range(n):
                if grid[i][j] == 1 and not visited[i][j]:
                    count += 1
                    self.dfs(grid, i, j, visited)
        return count
    
    def dfs(self, grid, i, j, visited):
        m, n = len(grid), len(grid[0])
        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]
        visited[i][j] = True
        for dx, dy in directions:
            nx, ny = i + dx, j + dy
            if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 1 and not visited[nx][ny]:
                self.dfs(grid, nx, ny, visited)
",,,,,,,,,,,,"90, 100","class Solution(object):
    def minDays(self, grid):
        """"""
        :type grid: List[List[int]]
        :rtype: int
        """"""
        m, n = len(grid), len(grid[0])
        if self.countIslands(grid) != 1:
            return 0
        
        for i in range(m):
            for j in range(n):
                if grid[i][j] == 1:
                    grid[i][j] = 0
                    if not self.isConnected(grid, m, n):
                        return 1
                    grid[i][j] = 1
        return 2
    
    def countIslands(self, grid):
        m, n = len(grid), len(grid[0])
        visited = [[False] * n for _ in range(m)]
        count = 0
        for i in range(m):
            for j in range(n):
                if grid[i][j] == 1 and not visited[i][j]:
                    count += 1
                    self.dfs(grid, i, j, visited)
        return count
    
    def dfs(self, grid, i, j, visited):
        m, n = len(grid), len(grid[0])
        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]
        visited[i][j] = True
        for dx, dy in directions:
            nx, ny = i + dx, j + dy
            if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 1 and not visited[nx][ny]:
                self.dfs(grid, nx, ny, visited)
    
    def isConnected(self, grid, m, n):
        visited = [[False] * n for _ in range(m)]
        count = 0
        for i in range(m):
            for j in range(n):
                if grid[i][j] == 1 and not visited[i][j]:
                    if count > 0:
                        return False
                    count += 1
                    self.dfs(grid, i, j, visited)
        return count == 1
","90, 60","class Solution(object):
    def minDays(self, grid):
        """"""
        :type grid: List[List[int]]
        :rtype: int
        """"""
        m, n = len(grid), len(grid[0])
        if self.countIslands(grid) != 1:
            return 0
        
        if self.canDisconnect(grid, m, n):
            return 1
        
        return 2
    
    def countIslands(self, grid):
        m, n = len(grid), len(grid[0])
        visited = [[False] * n for _ in range(m)]
        count = 0
        for i in range(m):
            for j in range(n):
                if grid[i][j] == 1 and not visited[i][j]:
                    count += 1
                    self.dfs(grid, i, j, visited)
        return count
    
    def dfs(self, grid, i, j, visited):
        m, n = len(grid), len(grid[0])
        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]
        visited[i][j] = True
        for dx, dy in directions:
            nx, ny = i + dx, j + dy
            if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 1 and not visited[nx][ny]:
                self.dfs(grid, nx, ny, visited)
    
    def canDisconnect(self, grid, m, n):
        for i in range(m):
            for j in range(n):
                if grid[i][j] == 1:
                    grid[i][j] = 0
                    if self.countIslands(grid) != 1:
                        grid[i][j] = 1
                        return True
                    grid[i][j] = 1
        return False
","90, 90","class Solution(object):
    def minDays(self, grid):
        """"""
        :type grid: List[List[int]]
        :rtype: int
        """"""
        m, n = len(grid), len(grid[0])
        if self.countIslands(grid) != 1:
            return 0
        
        island_cells = self.getIslandCells(grid, m, n)
        if self.canDisconnect(island_cells, grid, m, n):
            return 1
        
        return 2
    
    def countIslands(self, grid):
        m, n = len(grid), len(grid[0])
        visited = [[False] * n for _ in range(m)]
        count = 0
        for i in range(m):
            for j in range(n):
                if grid[i][j] == 1 and not visited[i][j]:
                    count += 1
                    self.dfs(grid, i, j, visited)
        return count
    
    def dfs(self, grid, i, j, visited):
        m, n = len(grid), len(grid[0])
        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]
        visited[i][j] = True
        for dx, dy in directions:
            nx, ny = i + dx, j + dy
            if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 1 and not visited[nx][ny]:
                self.dfs(grid, nx, ny, visited)
    
    def getIslandCells(self, grid, m, n):
        island_cells = set()
        for i in range(m):
            for j in range(n):
                if grid[i][j] == 1:
                    island_cells.add((i, j))
        return island_cells
    
    def canDisconnect(self, island_cells, grid, m, n):
        for cell in island_cells:
            i, j = cell
            grid[i][j] = 0
            if self.countIslands(grid) != 1:
                grid[i][j] = 1
                return True
            grid[i][j] = 1
        return False
","10, 60","class Solution(object):
    def minDays(self, grid):
        """"""
        :type grid: List[List[int]]
        :rtype: int
        """"""
        m, n = len(grid), len(grid[0])
        if self.countIslands(grid) != 1:
            return 0

        if self.isGridDisconnected(grid, m, n):
            return 1

        return 2

    def countIslands(self, grid):
        m, n = len(grid), len(grid[0])
        visited = [[False] * n for _ in range(m)]
        count = 0
        for i in range(m):
            for j in range(n):
                if grid[i][j] == 1 and not visited[i][j]:
                    count += 1
                    self.dfs(grid, i, j, visited)
        return count

    def dfs(self, grid, i, j, visited):
        m, n = len(grid), len(grid[0])
        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]
        visited[i][j] = True
        for dx, dy in directions:
            nx, ny = i + dx, j + dy
            if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 1 and not visited[nx][ny]:
                self.dfs(grid, nx, ny, visited)

    def isGridDisconnected(self, grid, m, n):
        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]
        island_cell = None
        for i in range(m):
            for j in range(n):
                if grid[i][j] == 1:
                    if island_cell is None:
                        island_cell = (i, j)
                    else:
                        return True  # Multiple islands found, grid is already disconnected

        if island_cell is None:
            return True  # No islands found, grid is already disconnected

        # Check if disconnecting the island results in a disconnected grid
        grid[island_cell[0]][island_cell[1]] = 0
        visited = [[False] * n for _ in range(m)]
        count = self.countIslands(grid)
        grid[island_cell[0]][island_cell[1]] = 1  # Restore the island cell
        return count != 1
",,,,"Wrong Answer

80 / 99 testcases passed
Input
grid =
[[0,1,1,0],[0,1,1,0],[0,0,0,0]]
Use Testcase

Output
1
Expected
2


"
54,Hard,2163,"class Solution(object):
    def minimumDifference(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        n = len(nums) // 3  # Calculate the value of n
        
        nums.sort()  # Sort the array in ascending order
        
        # Calculate the difference between the sums of the two parts after removing n elements
        diff = float('inf')  # Initialize diff with infinity
        
        # Try removing the largest n elements and calculate the difference
        for i in range(n, 2 * n):
            diff = min(diff, sum(nums[:n]) - sum(nums[n:i+1]))
        
        return diff
","Wrong Answer

2 / 110 testcases passed
Input
nums =
[7,9,5,8,1,3]
Use Testcase

Output
-8
Expected
1


","class Solution(object):
    def minimumDifference(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        n = len(nums) // 3  # Calculate the value of n
        
        nums.sort()  # Sort the array in ascending order
        
        # Calculate the difference between the sums of the two parts after removing n elements
        diff = float('inf')  # Initialize diff with infinity
        
        # Try removing the largest n elements and calculate the difference
        for i in range(n, 2 * n):
            diff = min(diff, sum(nums[n:i+1]) - sum(nums[:n]))
        
        return diff
","Wrong Answer

2 / 110 testcases passed
Input
nums =
[3,1,2]
Use Testcase

Output
1
Expected
-1


","class Solution(object):
    def minimumDifference(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        n = len(nums) // 3  # Calculate the value of n
        
        nums.sort()  # Sort the array in ascending order
        
        running_sum = 0  # Running sum of the largest n elements
        total_sum = sum(nums[-2 * n:])  # Sum of the last 2n elements
        
        min_diff = float('inf')  # Initialize the minimum difference with infinity
        
        # Calculate the difference for each possible split
        for i in range(n, 2 * n):
            running_sum += nums[i]
            diff = total_sum - 2 * running_sum
            min_diff = min(min_diff, abs(diff))
        
        return min_diff
","Wrong Answer

8 / 110 testcases passed
Input
nums =
[3,1,2]
Use Testcase

Output
1
Expected
-1


","class Solution(object):
    def minimumDifference(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        n = len(nums) // 3  # Calculate the value of n

        # Create a dynamic programming table to store the minimum difference
        dp = [[float('inf')] * (n + 1) for _ in range(n + 1)]

        dp[0][0] = 0  # Base case: no elements selected

        # Iterate through the array and update the minimum difference table
        for i in range(1, len(nums) + 1):
            for j in range(min(i, n), -1, -1):
                for k in range(min(i, n), -1, -1):
                    if j > 0:
                        dp[j][k] = min(dp[j][k], dp[j - 1][k] + nums[i - 1])
                    if k > 0:
                        dp[j][k] = min(dp[j][k], dp[j][k - 1] - nums[i - 1])

        # Return the minimum difference between the two parts
        return dp[n][n]
","Wrong Answer

0 / 110 testcases passed
Input
nums =
[3,1,2]
Use Testcase

Output
-2
Expected
-1


","class Solution(object):
    def minimumDifference(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        n = len(nums) // 3  # Calculate the value of n
        
        self.min_diff = float('inf')  # Initialize the minimum difference with infinity
        
        def dfs(index, count, sum_first):
            if count == n:
                sum_second = sum(nums) - sum_first
                self.min_diff = min(self.min_diff, abs(sum_first - sum_second))
                return
            
            if index == len(nums):
                return
            
            # Include the current element in the first part
            dfs(index + 1, count + 1, sum_first + nums[index])
            
            # Exclude the current element from the first part
            dfs(index + 1, count, sum_first)
        
        dfs(0, 0, 0)  # Start the recursive exploration
        
        return self.min_diff
","Wrong Answer

1 / 110 testcases passed
Input
nums =
[3,1,2]
Use Testcase

Output
0
Expected
-1


","class Solution(object):
    def minimumDifference(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        n = len(nums) // 3  # Calculate the value of n

        nums.sort()  # Sort the array in ascending order

        # Initialize the pointers
        left = n  # Pointer for the first part
        right = 2 * n  # Pointer for the second part

        # Calculate the initial sums of the two parts
        sum_first = sum(nums[:left])
        sum_second = sum(nums[left:right])

        # Initialize the minimum difference
        min_diff = abs(sum_first - sum_second)

        # Move the pointers inward to find the minimum difference
        while right < len(nums):
            sum_first += nums[left]
            sum_second -= nums[left]
            left += 1
            right += 1
            min_diff = min(min_diff, abs(sum_first - sum_second))

        return min_diff
","Wrong Answer

4 / 110 testcases passed
Input
nums =
[3,1,2]
Use Testcase

Output
1
Expected
-1


",,,,,,,,,,,,
55,Hard,1830,"class Solution(object):
    def makeStringSorted(self, s):
        MOD = 10**9 + 7
        n = len(s)
        factorials = [1] * (n + 1)
        for i in range(1, n + 1):
            factorials[i] = (factorials[i - 1] * i) % MOD

        freq = [0] * 26
        for c in s:
            freq[ord(c) - ord('a')] += 1

        result = 0
        for i in range(n):
            # Calculate the number of characters smaller than s[i] that occur after s[i]
            smaller_count = sum(freq[:ord(s[i]) - ord('a')]) % MOD

            for j in range(26):
                if freq[j] > 0:
                    freq[j] -= 1
                    # Calculate the number of permutations of the remaining characters
                    permutations = factorials[n - i - 1] % MOD
                    for k in range(26):
                        if freq[k] > 1:
                            # Divide by the factorial of the frequencies of repeated characters
                            permutations = (permutations * pow(factorials[freq[k]], MOD - 2, MOD)) % MOD

                    # Add the number of permutations of the remaining characters to the result
                    result = (result + (smaller_count * permutations) % MOD) % MOD

                    freq[j] += 1

            freq[ord(s[i]) - ord('a')] -= 1

        return result
","Wrong Answer

0 / 73 testcases passed
Input
s =
""cba""
Use Testcase

Output
14
Expected
5


","class Solution(object):
    def makeStringSorted(self, s):
        MOD = 10**9 + 7
        n = len(s)
        factorials = [1] * (n + 1)
        for i in range(1, n + 1):
            factorials[i] = (factorials[i - 1] * i) % MOD

        freq = [0] * 26
        for c in s:
            freq[ord(c) - ord('a')] += 1

        result = 0
        for i in range(n):
            smaller_count = sum(freq[:ord(s[i]) - ord('a')]) % MOD
            for j in range(26):
                if freq[j] > 0 and j < ord(s[i]) - ord('a'):
                    freq[j] -= 1
                    # Calculate the number of permutations of the remaining characters
                    permutations = factorials[n - i - 1] % MOD
                    for k in range(26):
                        if freq[k] > 1:
                            # Divide by the factorial of the frequencies of repeated characters
                            permutations = (permutations * pow(factorials[freq[k]], MOD - 2, MOD)) % MOD

                    # Add the number of permutations of the remaining characters to the result
                    result = (result + (smaller_count * permutations) % MOD) % MOD
                    freq[j] += 1

            freq[ord(s[i]) - ord('a')] -= 1

        return result
","Wrong Answer

0 / 73 testcases passed
Input
s =
""cba""
Use Testcase

Output
9
Expected
5


","class Solution(object):
    def makeStringSorted(self, s):
        MOD = 10**9 + 7
        n = len(s)
        factorials = [1] * (n + 1)
        for i in range(1, n + 1):
            factorials[i] = (factorials[i - 1] * i) % MOD

        freq = [0] * 26
        for c in s:
            freq[ord(c) - ord('a')] += 1

        result = 0
        for i in range(n):
            smaller_count = sum(freq[:ord(s[i]) - ord('a')]) % MOD
            for j in range(ord(s[i]) - ord('a')):
                if freq[j] > 0:
                    freq[j] -= 1
                    # Calculate the number of permutations of the remaining characters
                    permutations = factorials[n - i - 1] % MOD
                    for k in range(26):
                        if freq[k] > 1:
                            # Divide by the factorial of the frequencies of repeated characters
                            permutations = (permutations * pow(factorials[freq[k]], MOD - 2, MOD)) % MOD

                    # Add the number of permutations of the remaining characters to the result
                    result = (result + (smaller_count * permutations) % MOD) % MOD
                    freq[j] += 1

            freq[ord(s[i]) - ord('a')] -= 1

        return result
","Wrong Answer

0 / 73 testcases passed
Input
s =
""cba""
Use Testcase

Output
9
Expected
5


","class Solution(object):
    def makeStringSorted(self, s):
        MOD = 10**9 + 7
        n = len(s)
        factorials = [1] * (n + 1)
        for i in range(1, n + 1):
            factorials[i] = (factorials[i - 1] * i) % MOD

        freq = [0] * 26
        for c in s:
            freq[ord(c) - ord('a')] += 1

        result = 0
        for i in range(n):
            smaller_count = sum(freq[:ord(s[i]) - ord('a')]) % MOD
            for j in range(ord(s[i]) - ord('a')):
                if freq[j] > 0:
                    freq[j] -= 1
                    # Calculate the number of permutations of the remaining characters
                    permutations = factorials[n - i - 1] % MOD
                    for k in range(26):
                        if freq[k] > 1:
                            # Divide by the factorial of the frequencies of repeated characters
                            permutations = (permutations * pow(factorials[freq[k]], MOD - 2, MOD)) % MOD

                    # Add the number of permutations of the remaining characters to the result
                    result = (result + (smaller_count * permutations) % MOD) % MOD
                    freq[j] += 1

            freq[ord(s[i]) - ord('a')] -= 1

        return result % MOD
","Wrong Answer

0 / 73 testcases passed
Input
s =
""cba""
Use Testcase

Output
9
Expected
5


","class Solution(object):
    def makeStringSorted(self, s):
        MOD = 10**9 + 7
        n = len(s)
        factorials = [1] * (n + 1)
        for i in range(1, n + 1):
            factorials[i] = (factorials[i - 1] * i) % MOD

        freq = [0] * 26
        for c in s:
            freq[ord(c) - ord('a')] += 1

        result = 0
        for i in range(n):
            smaller_count = sum(freq[:ord(s[i]) - ord('a')]) % MOD
            for j in range(ord(s[i]) - ord('a')):
                if freq[j] > 0:
                    freq[j] -= 1
                    # Calculate the number of permutations of the remaining characters
                    permutations = factorials[n - i - 1] % MOD
                    for k in range(26):
                        if freq[k] > 1:
                            # Divide by the factorial of the frequencies of repeated characters
                            permutations = (permutations * pow(factorials[freq[k]], MOD - 2, MOD)) % MOD

                    # Add the number of permutations of the remaining characters to the result
                    result = (result + (smaller_count * permutations) % MOD) % MOD
                    freq[j] += 1

            freq[ord(s[i]) - ord('a')] -= 1

        return result % MOD
","Wrong Answer

0 / 73 testcases passed
Input
s =
""cba""
Use Testcase

Output
9
Expected
5


","class Solution(object):
    def makeStringSorted(self, s):
        MOD = 10**9 + 7
        n = len(s)
        factorials = [1] * (n + 1)
        for i in range(1, n + 1):
            factorials[i] = (factorials[i - 1] * i) % MOD

        freq = [0] * 26
        for c in s:
            freq[ord(c) - ord('a')] += 1

        result = 0
        for i in range(n):
            smaller_count = sum(freq[:ord(s[i]) - ord('a')]) % MOD
            for j in range(ord(s[i]) - ord('a')):
                if freq[j] > 0:
                    freq[j] -= 1
                    # Calculate the number of permutations of the remaining characters
                    permutations = factorials[n - i - 1] % MOD
                    for k in range(26):
                        if freq[k] > 1:
                            # Divide by the factorial of the frequencies of repeated characters
                            permutations = (permutations * pow(factorials[freq[k]], MOD - 2, MOD)) % MOD

                    # Add the number of permutations of the remaining characters to the result
                    result = (result + (smaller_count * permutations) % MOD) % MOD
                    freq[j] += 1

            freq[ord(s[i]) - ord('a')] -= 1

        return result % MOD
","Wrong Answer

0 / 73 testcases passed
Input
s =
""cba""
Use Testcase

Output
9
Expected
5


",,,,,,,,,,,,
56,Hard,25,"# Definition for singly-linked list.
class ListNode(object):
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class Solution(object):
    def reverseKGroup(self, head, k):
        """"""
        :type head: ListNode
        :type k: int
        :rtype: ListNode
        """"""
        # Function to reverse a linked list
        def reverseLinkedList(head):
            prev = None
            curr = head
            while curr:
                next_node = curr.next
                curr.next = prev
                prev = curr
                curr = next_node
            return prev
        
        # Count the number of nodes in the linked list
        def countNodes(head):
            count = 0
            curr = head
            while curr:
                count += 1
                curr = curr.next
            return count
        
        # Check if there are at least k nodes remaining in the linked list
        def hasKNodesRemaining(head, k):
            count = countNodes(head)
            return count >= k
        
        # Reverse k nodes in the linked list
        def reverseKNodes(head, k):
            if not hasKNodesRemaining(head, k):
                return head
            prev = None
            curr = head
            for _ in range(k):
                next_node = curr.next
                curr.next = prev
                prev = curr
                curr = next_node
            head.next = reverseKNodes(curr, k)
            return prev
        
        # Main function to reverse nodes in k groups
        if not head or k == 1:
            return head
        if not hasKNodesRemaining(head, k):
            return head
        new_head = reverseKNodes(head, k)
        return new_head
",,,,,,,,,,,,"83.48, 76.4","# Definition for singly-linked list.
class ListNode(object):
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class Solution(object):
    def reverseKGroup(self, head, k):
        """"""
        :type head: ListNode
        :type k: int
        :rtype: ListNode
        """"""
        # Count the number of nodes in the linked list
        def countNodes(head):
            count = 0
            curr = head
            while curr:
                count += 1
                curr = curr.next
            return count
        
        # Reverse k nodes in the linked list
        def reverseKNodes(head, k):
            if not head or not head.next:
                return head, None
            count = 0
            prev = None
            curr = head
            while curr and count < k:
                next_node = curr.next
                curr.next = prev
                prev = curr
                curr = next_node
                count += 1
            if count < k:
                # If there are fewer than k nodes remaining,
                # reverse the reversed nodes again to restore the original order
                new_head, tail = reverseKNodes(prev, count)
                prev.next = tail
                return new_head, head
            else:
                return prev, head
        
        # Main function to reverse nodes in k groups
        if not head or k == 1:
            return head
        count = countNodes(head)
        if count < k:
            return head
        dummy = ListNode(0)
        dummy.next = head
        prev = dummy
        while count >= k:
            new_head, tail = reverseKNodes(prev.next, k)
            prev.next = new_head
            prev = tail
            count -= k
        return dummy.next
",,,,,,,,,,"Wrong Answer

10 / 62 testcases passed
Input
head =
[1,2,3,4,5]
k =
2
Use Testcase

Output
[2,1]
Expected
[2,1,4,3,5]


"
57,Hard,1956,"from collections import deque

class Solution(object):
    def minDayskVariants(self, points, k):
        """"""
        :type points: List[List[int]]
        :type k: int
        :rtype: int
        """"""
        # Create a set to store the initial points
        initial_points = set(tuple(point) for point in points)
        
        # Perform BFS iterations
        queue = deque([(0, initial_points)])
        visited = set(initial_points)
        
        while queue:
            days, infected_points = queue.popleft()
            
            # Check if any point contains at least k variants
            for point in infected_points:
                if len(infected_points.intersection(initial_points)) >= k:
                    return days
            
            # Spread the viruses to neighboring points
            new_infected_points = set()
            for x, y in infected_points:
                for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                    new_x, new_y = x + dx, y + dy
                    if (new_x, new_y) not in visited:
                        new_infected_points.add((new_x, new_y))
                        visited.add((new_x, new_y))
            
            # Add the newly infected points to the queue
            if new_infected_points:
                queue.append((days + 1, new_infected_points))
        
        # If no point contains at least k variants
        return -1
","Wrong Answer

1 / 70 testcases passed
Input
points =
[[1,1],[6,1]]
k =
2
Use Testcase

Output
0
Expected
3


","from collections import deque

class Solution(object):
    def minDayskVariants(self, points, k):
        """"""
        :type points: List[List[int]]
        :type k: int
        :rtype: int
        """"""
        # Create a set to store the initial points
        initial_points = set(tuple(point) for point in points)
        
        # Perform BFS iterations
        queue = deque([(0, initial_points)])
        visited = set(initial_points)
        
        while queue:
            days, infected_points = queue.popleft()
            
            # Check if any point contains at least k variants
            for point in infected_points:
                count = 0
                for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                    neighbor = (point[0] + dx, point[1] + dy)
                    if neighbor in initial_points:
                        count += 1
                        if count >= k:
                            return days + 1
            
            # Spread the viruses to neighboring points
            new_infected_points = set()
            for x, y in infected_points:
                for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                    new_x, new_y = x + dx, y + dy
                    if (new_x, new_y) not in visited:
                        new_infected_points.add((new_x, new_y))
                        visited.add((new_x, new_y))
            
            # Add the newly infected points to the queue
            if new_infected_points:
                queue.append((days + 1, new_infected_points))
        
        # If no point contains at least k variants
        return -1
","Time Limit Exceeded
0 / 70 testcases passed
Last Executed Input
Use Testcase

points =
[[1,1],[6,1]]

k =
2

","class Solution:
    def minDayskVariants(self, points, k):
        """"""
        :type points: List[List[int]]
        :type k: int
        :rtype: int
        """"""
        def find(x):
            if parent[x] != x:
                parent[x] = find(parent[x])
            return parent[x]

        def union(x, y):
            root_x = find(x)
            root_y = find(y)
            if root_x != root_y:
                parent[root_x] = root_y
                self.component_count -= 1

        def count_components(points):
            n = len(points)
            parent = {i: i for i in range(n)}
            self.component_count = n

            for i in range(n):
                for j in range(i + 1, n):
                    if abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1]) <= 1:
                        union(i, j)

            return self.component_count

        # Check if it's possible to have k variants
        if count_components(points) < k:
            return -1

        # Binary search for the minimum number of days
        left = 0
        right = 100
        while left < right:
            mid = left + (right - left) // 2
            if count_components(points) <= k:
                right = mid
            else:
                left = mid + 1

        return left
","Wrong Answer

0 / 70 testcases passed
Input
points =
[[1,1],[6,1]]
k =
2
Use Testcase

Output
0
Expected
3


","from collections import deque

class Solution:
    def minDayskVariants(self, points, k):
        """"""
        :type points: List[List[int]]
        :type k: int
        :rtype: int
        """"""
        def spread_virus(grid, queue):
            directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]
            infected_points = set(queue)
            days = 0
            
            while queue:
                for _ in range(len(queue)):
                    x, y = queue.popleft()
                    for dx, dy in directions:
                        nx, ny = x + dx, y + dy
                        if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and grid[nx][ny] == 0:
                            grid[nx][ny] = 1
                            infected_points.add((nx, ny))
                            queue.append((nx, ny))
                days += 1
            
            return infected_points, days
        
        grid = [[0] * 101 for _ in range(101)]
        
        for x, y in points:
            grid[x][y] = 1
        
        queue = deque(points)
        infected_points, days = spread_virus(grid, queue)
        
        while len(infected_points) < k and queue:
            new_infected_points, new_days = spread_virus(grid, queue)
            infected_points.update(new_infected_points)
            days += new_days
        
        return days if len(infected_points) >= k else -1
","Runtime Error
0 / 70 testcases passed
TypeError: unhashable type: 'list'
    infected_points = set(queue)
Line 12 in spread_virus (Solution.py)
    infected_points, days = spread_virus(grid, queue)
Line 34 in minDayskVariants (Solution.py)
    ret = Solution().minDayskVariants(param_1, param_2)
Line 66 in _driver (Solution.py)
    _driver()
Line 76 in <module> (Solution.py)
Last Executed Input
Use Testcase

points =
[[1,1],[6,1]]

k =
2

","from collections import deque

class Solution:
    def minDayskVariants(self, points, k):
        """"""
        :type points: List[List[int]]
        :type k: int
        :rtype: int
        """"""
        def spread_virus(grid, queue):
            directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]
            infected_points = set(queue)
            days = 0
            
            while queue:
                new_queue = deque()
                for _ in range(len(queue)):
                    x, y = queue.popleft()
                    for dx, dy in directions:
                        nx, ny = x + dx, y + dy
                        if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and grid[nx][ny] == 0:
                            grid[nx][ny] = 1
                            infected_points.add((nx, ny))
                            new_queue.append((nx, ny))
                queue = new_queue
                days += 1
            
            return infected_points, days
        
        grid = [[0] * 101 for _ in range(101)]
        
        for x, y in points:
            grid[x][y] = 1
        
        queue = deque(tuple(point) for point in points)
        infected_points, days = spread_virus(grid, queue)
        
        while len(infected_points) < k and queue:
            new_infected_points, new_days = spread_virus(grid, queue)
            infected_points.update(new_infected_points)
            days += new_days
        
        return days if len(infected_points) >= k else -1
","Wrong Answer

1 / 70 testcases passed
Input
points =
[[1,1],[6,1]]
k =
2
Use Testcase

Output
194
Expected
3


","class Solution:
    def minDayskVariants(self, points, k):
        """"""
        :type points: List[List[int]]
        :type k: int
        :rtype: int
        """"""
        def simulate_spread(grid, days):
            directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]
            visited = set()
            
            def dfs(x, y):
                if x < 0 or x >= rows or y < 0 or y >= cols or grid[x][y] == 0 or (x, y) in visited:
                    return 0
                visited.add((x, y))
                count = 1
                for dx, dy in directions:
                    count += dfs(x + dx, y + dy)
                return count
            
            rows, cols = len(grid), len(grid[0])
            
            for x, y in points:
                grid[x][y] = 0
            
            for _ in range(days):
                infected = []
                for x in range(rows):
                    for y in range(cols):
                        if grid[x][y] == 1:
                            infected.append((x, y))
                if len(infected) >= k:
                    return True
                for x, y in infected:
                    for dx, dy in directions:
                        nx, ny = x + dx, y + dy
                        if 0 <= nx < rows and 0 <= ny < cols and grid[nx][ny] == 0:
                            grid[nx][ny] = 1
                if not infected:
                    break
            
            return False
        
        # Binary search for the minimum number of days
        left, right = 0, 1000000
        while left < right:
            mid = (left + right) // 2
            grid = [[0] * 101 for _ in range(101)]
            for x, y in points:
                grid[x][y] = 1
            if simulate_spread(grid, mid):
                right = mid
            else:
                left = mid + 1
        
        return left if left < 1000000 else -1
","Wrong Answer

0 / 70 testcases passed
Input
points =
[[1,1],[6,1]]
k =
2
Use Testcase

Output
-1
Expected
3


",,,,,,,,,,,,
58,Hard,975,"class Solution(object):
    def oddEvenJumps(self, arr):
        """"""
        :type arr: List[int]
        :rtype: int
        """"""
        n = len(arr)
        next_higher, next_lower = [0] * n, [0] * n
        stack = []
        indices = sorted(range(n), key=lambda i: arr[i])
        
        for i in indices:
            while stack and i > stack[-1]:
                next_higher[stack.pop()] = i
            stack.append(i)
        
        stack = []
        indices.sort(key=lambda i: -arr[i])
        for i in indices:
            while stack and i > stack[-1]:
                next_lower[stack.pop()] = i
            stack.append(i)
        
        odd_jump, even_jump = [False] * n, [False] * n
        odd_jump[-1] = even_jump[-1] = True
        
        for i in range(n-2, -1, -1):
            if next_higher[i] > 0:
                odd_jump[i] = even_jump[next_higher[i]]
            if next_lower[i] > 0:
                even_jump[i] = odd_jump[next_lower[i]]
        
        return sum(odd_jump)
",,,,,,,,,,,,"100, 100","class Solution(object):
    def oddEvenJumps(self, arr):
        """"""
        :type arr: List[int]
        :rtype: int
        """"""
        n = len(arr)
        next_higher = [0] * n
        next_lower = [0] * n

        stack = []
        for i in range(n - 1, -1, -1):
            while stack and arr[i] > arr[stack[-1]]:
                next_higher[stack.pop()] = i
            stack.append(i)

        stack = []
        for i in range(n - 1, -1, -1):
            while stack and arr[i] < arr[stack[-1]]:
                next_lower[stack.pop()] = i
            stack.append(i)

        odd_jump = [False] * n
        even_jump = [False] * n
        odd_jump[-1] = even_jump[-1] = True

        for i in range(n - 2, -1, -1):
            if next_higher[i] > 0:
                odd_jump[i] = even_jump[next_higher[i]]
            if next_lower[i] > 0:
                even_jump[i] = odd_jump[next_lower[i]]

        return sum(odd_jump)
",,,,,,,,,,"Wrong Answer

8 / 65 testcases passed
Input
arr =
[10,13,12,14,15]
Use Testcase

Output
1
Expected
2


"
59,Hard,761,"class Solution(object):
    def makeLargestSpecial(self, s):
        """"""
        :type s: str
        :rtype: str
        """"""
        def make_special(s):
            if s == """":
                return """"

            count = 0
            substrings = []
            start = 0

            for i, char in enumerate(s):
                if char == ""1"":
                    count += 1
                else:
                    count -= 1

                if count == 0:
                    substrings.append(""1"" + make_special(s[start+1:i]) + ""0"")
                    start = i + 1

            substrings.sort(reverse=True)
            return """".join(substrings)

        return make_special(s)
",,,,,,,,,,,,"50, 100","class Solution(object):
    def makeLargestSpecial(self, s):
        """"""
        :type s: str
        :rtype: str
        """"""
        def make_special(s):
            if s == """":
                return """"

            count = 0
            substrings = []
            start = 0
            result = """"

            for i, char in enumerate(s):
                if char == ""1"":
                    count += 1
                else:
                    count -= 1

                if count == 0:
                    substr = ""1"" + make_special(s[start+1:i]) + ""0""
                    substrings.append(substr)
                    start = i + 1

            substrings.sort(reverse=True)
            return result.join(substrings)

        return make_special(s)
","75, 50","class Solution(object):
    def makeLargestSpecial(self, s):
        """"""
        :type s: str
        :rtype: str
        """"""
        def make_special(s):
            substrings = []
            count = i = 0

            for j, char in enumerate(s):
                count = count + 1 if char == ""1"" else count - 1

                if count == 0:
                    substr = ""1"" + make_special(s[i+1:j]) + ""0""
                    substrings.append(substr)
                    i = j + 1

            substrings.sort(reverse=True)
            return """".join(substrings)

        return make_special(s)
","50, 50","class Solution(object):
    def makeLargestSpecial(self, s):
        """"""
        :type s: str
        :rtype: str
        """"""
        def make_special(s):
            substrings = []
            count = i = 0
            result = """"

            for j, char in enumerate(s):
                count = count + 1 if char == ""1"" else count - 1

                if count == 0:
                    substr = ""1"" + make_special(s[i+1:j]) + ""0""
                    substrings.append(substr)
                    i = j + 1

            substrings.sort(reverse=True)
            return result.join(substrings)

        return make_special(s)
","62.5, 50","class Solution(object):
    def makeLargestSpecial(self, s):
        """"""
        :type s: str
        :rtype: str
        """"""
        def make_special(s):
            substrings = []
            count = i = 0
            result = """"

            for j, char in enumerate(s):
                count = count + 1 if char == ""1"" else count - 1

                if count == 0:
                    substr = ""1"" + make_special(s[i+1:j]) + ""0""
                    substrings.append(substr)
                    i = j + 1

            substrings.sort(reverse=True)
            return """".join(substrings)

        return make_special(s)
","62.5, 100","class Solution(object):
    def makeLargestSpecial(self, s):
        """"""
        :type s: str
        :rtype: str
        """"""
        def make_special(s):
            substrings = []
            count = i = 0
            result = """"

            for j, char in enumerate(s):
                count = count + 1 if char == ""1"" else count - 1

                if count == 0:
                    substr = ""1"" + make_special(s[i+1:j]) + ""0""
                    substrings.append(substr)
                    i = j + 1

            substrings.sort(reverse=True)
            return """".join(substrings)

        return make_special(s)
","62.5, 100",
60,Hard,2263,"class Solution(object):
    def convertArray(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        def count_operations(arr):
            """"""
            Helper function to count the number of operations to make the array non-decreasing or non-increasing.
            """"""
            count = 0
            for i in range(1, len(arr)):
                diff = abs(arr[i] - arr[i-1])
                count += diff
                arr[i] = arr[i-1]
            return count
        
        increasing_count = count_operations(nums[:])
        decreasing_count = count_operations(nums[::-1])
        
        return min(increasing_count, decreasing_count)
","Wrong Answer

12 / 110 testcases passed
Input
nums =
[3,2,4,5,0]
Use Testcase

Output
7
Expected
4


","class Solution(object):
    def convertArray(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        def count_operations(arr, increment):
            """"""
            Helper function to count the number of operations to make the array non-decreasing or non-increasing.
            """"""
            count = 0
            for i in range(1, len(arr)):
                if increment and arr[i] < arr[i-1]:
                    count += arr[i-1] - arr[i]
                    arr[i] = arr[i-1]
                elif not increment and arr[i] > arr[i-1]:
                    count += arr[i] - arr[i-1]
                    arr[i-1] = arr[i]
            return count
        
        increasing_count = count_operations(nums[:], True)
        decreasing_count = count_operations(nums[::-1], False)
        
        return min(increasing_count, decreasing_count)
","Wrong Answer

41 / 110 testcases passed
Input
nums =
[3,2,4,5,0]
Use Testcase

Output
6
Expected
4


","class Solution(object):
    def convertArray(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        def count_operations(arr):
            """"""
            Helper function to count the number of operations to make the array non-decreasing or non-increasing.
            """"""
            count = 0
            for i in range(1, len(arr)):
                if arr[i] < arr[i-1]:
                    count += arr[i-1] - arr[i]
                    arr[i] = arr[i-1]
            return count
        
        increasing_count = count_operations(nums[:])
        nums.reverse()  # Reverse the array
        decreasing_count = count_operations(nums[:])
        
        return min(increasing_count, decreasing_count)
","Wrong Answer

36 / 110 testcases passed
Input
nums =
[3,2,4,5,0]
Use Testcase

Output
6
Expected
4

","class Solution(object):
    def convertArray(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        def count_operations(arr):
            """"""
            Helper function to count the number of operations to make the array non-decreasing or non-increasing.
            """"""
            count = 0
            for i in range(1, len(arr)):
                diff = arr[i] - arr[i-1]
                if diff < 0:
                    count -= diff
            return count
        
        increasing_count = count_operations(nums[:])
        nums.reverse()  # Reverse the array
        decreasing_count = count_operations(nums[:])
        
        return min(increasing_count, decreasing_count)
","Wrong Answer

55 / 110 testcases passed
Input
nums =
[3,2,4,5,0]
Use Testcase

Output
3
Expected
4


","class Solution(object):
    def convertArray(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        def count_operations(arr, increment):
            """"""
            Helper function to count the number of operations to make the array non-decreasing or non-increasing.
            """"""
            count = 0
            for i in range(1, len(arr)):
                if increment and arr[i] < arr[i-1]:
                    count += arr[i-1] - arr[i]
                    arr[i] = arr[i-1]
                elif not increment and arr[i] > arr[i-1]:
                    count += arr[i] - arr[i-1]
                    arr[i] = arr[i-1]
            return count
        
        increasing_count = count_operations(nums[:], True)
        decreasing_count = count_operations(nums[:], False)
        
        return min(increasing_count, decreasing_count)
","Wrong Answer

38 / 110 testcases passed
Input
nums =
[3,2,4,5,0]
Use Testcase

Output
5
Expected
4
","class Solution(object):
    def convertArray(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        def count_operations(arr, increment):
            """"""
            Helper function to count the number of operations to make the array non-decreasing or non-increasing.
            """"""
            count = 0
            for i in range(1, len(arr)):
                if increment and arr[i] < arr[i-1]:
                    count += arr[i-1] - arr[i]
                elif not increment and arr[i] > arr[i-1]:
                    count += arr[i] - arr[i-1]
            return count
        
        increasing_count = count_operations(nums[:], True)
        decreasing_count = count_operations(nums[:], False)
        
        return min(increasing_count, decreasing_count)
","Wrong Answer

55 / 110 testcases passed
Input
nums =
[3,2,4,5,0]
Use Testcase

Output
3
Expected
4


",,,,,,,,,,,,